<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>React New Notes</title>
    <link rel="stylesheet" href="../../assests/css/bootstrap.min.css">
    <link rel="stylesheet" href="../../assests/css/style.css">
    <link rel="stylesheet" href="../../assests/css/prism-tomorrow.min.css">
</head>

<body>

    <div class="details-container">

        <details>
            <summary><strong>Directory Structure</strong></summary>
            <div class="content">
                <p>A well-structured <strong>React project
                        directory</strong> is crucial for scalability, maintainability, and collaboration. While the
                    exact
                    structure depends on project requirements, below is a typical structure used for medium-to-large
                    React
                    applications following modern best practices.</p>
                <hr>
                <h3><strong>Example Directory Structure</strong></h3>
                <pre tabindex="0"><code class="language-java">src/
  ├── assets/
  │   ├── images/
  │   ├── fonts/
  │   └── styles/
  ├── components/
  │   ├── common/
  │   ├── layout/
  │   └── specific/
  ├── features/
  │   ├── feature1/
  │   │   ├── components/
  │   │   ├── hooks/
  │   │   ├── services/
  │   │   └── feature1Slice.js
  │   └── feature2/
  ├── hooks/
  ├── pages/
  │   ├── Home/
  │   ├── About/
  │   └── NotFound/
  ├── services/
  ├── store/
  │   ├── slices/
  │   └── store.js
  ├── utils/
  ├── App.js
  ├── index.js
  └── config/
  </code></pre>
                <hr>
                <h3><strong>1.
                    </strong><code><strong>src/</strong></code></h3>
                <p>This is the root folder for all the source code.
                    Inside <code>src</code>, you’ll find all application logic, components, assets, and configurations.
                </p>
                <hr>
                <h3><strong>2.
                    </strong><code><strong>assets/</strong></code></h3>
                <p>This folder contains static files such as images,
                    fonts, and global styles.</p>
                <ul>
                    <li><strong>Purpose</strong>: Centralized location for reusable static
                        assets.</li>
                </ul>
                <p><strong>Example Structure</strong>:</p>
                <pre tabindex="0"><code class="language-java">assets/
  ├── images/
  │   └── logo.png
  ├── fonts/
  │   └── Roboto.ttf
  └── styles/
    ├── variables.css
    └── global.css
  </code></pre>
                <hr>
                <h3><strong>3.
                    </strong><code><strong>components/</strong></code></h3>
                <p>This is where reusable React components live.
                    Components in this folder are generally small, independent, and reusable across different parts of
                    the
                    app.</p>
                <p><strong>Common Subfolders</strong>:</p>
                <ul>
                    <li><strong>common/</strong>: Generic, reusable components like
                        buttons,
                        inputs, or modals.</li>
                </ul>
                <ul>
                    <li><strong>layout/</strong>: Components that manage the layout of the
                        app,
                        like headers, footers, or sidebars.</li>
                </ul>
                <ul>
                    <li><strong>specific/</strong>: Components specific to certain use
                        cases
                        but not tied to a single feature.</li>
                </ul>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">components/
  ├── common/
  │   ├── Button.js
  │   ├── Input.js
  │   └── Modal.js
  ├── layout/
  │   ├── Header.js
  │   └── Footer.js
  └── specific/
    └── UserCard.js
  </code></pre>
                <hr>
                <h3><strong>4.
                    </strong><code><strong>features/</strong></code></h3>
                <p>Each major feature gets its own folder with all
                    related files grouped together. This is especially useful in large apps following the
                    <strong>feature-based architecture</strong>.
                </p>
                <p><strong>Structure</strong>:</p>
                <pre tabindex="0"><code class="language-java">features/
  ├── feature1/
  │   ├── components/
  │   ├── hooks/
  │   ├── services/
  │   └── feature1Slice.js
  └── feature2/
    └── ...
  </code></pre>
                <ul>
                    <li><strong>components/</strong>: Components specific to this feature.
                    </li>
                </ul>
                <ul>
                    <li><strong>hooks/</strong>: Custom React hooks for this feature.</li>
                </ul>
                <ul>
                    <li><strong>services/</strong>: API calls or other business logic for
                        this
                        feature.</li>
                </ul>
                <ul>
                    <li><strong>feature1Slice.js</strong>: Redux slice or state logic for
                        this
                        feature.</li>
                </ul>
                <hr>
                <h3><strong>5.
                    </strong><code><strong>hooks/</strong></code></h3>
                <p>This folder contains reusable custom hooks for
                    shared logic.</p>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">hooks/
  ├── useAuth.js
  ├── useFetch.js
  └── useToggle.js
  </code></pre>
                <hr>
                <h3><strong>6.
                    </strong><code><strong>pages/</strong></code></h3>
                <p>This folder contains components that represent
                    entire pages in the app, usually tied to routes.</p>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">pages/
  ├── Home/
  │   ├── Home.js
  │   ├── Home.css
  │   └── Home.test.js
  ├── About/
  │   └── About.js
  └── NotFound/
    └── NotFound.js
  </code></pre>
                <ul>
                    <li><strong>Home.js</strong>: Represents the homepage of the app.</li>
                </ul>
                <ul>
                    <li><strong>NotFound.js</strong>: A fallback page for undefined routes.
                    </li>
                </ul>
                <hr>
                <h3><strong>7.
                    </strong><code><strong>services/</strong></code></h3>
                <p>This folder contains logic for making API calls and
                    interacting with external services.</p>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">services/
  ├── api.js
  └── userService.js
  </code></pre>
                <ul>
                    <li><strong>api.js</strong>: Centralized instance of Axios or Fetch.
                    </li>
                </ul>
                <ul>
                    <li><strong>userService.js</strong>: Functions like
                        <code>getUser()</code>
                        or <code>updateUser()</code>.
                    </li>
                </ul>
                <hr>
                <h3><strong>8.
                    </strong><code><strong>store/</strong></code></h3>
                <p>For applications using state management libraries
                    like Redux or Zustand.</p>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">store/
  ├── slices/
  │   ├── userSlice.js
  │   ├── productSlice.js
  │   └── cartSlice.js
  └── store.js
  </code></pre>
                <ul>
                    <li><strong>slices/</strong>: Redux slices or similar state management
                        logic.</li>
                </ul>
                <ul>
                    <li><strong>store.js</strong>: Main configuration for the store.</li>
                </ul>
                <hr>
                <h3><strong>9.
                    </strong><code><strong>utils/</strong></code></h3>
                <p>Contains utility functions, helpers, and reusable
                    logic that doesn’t fit anywhere else.</p>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">utils/
  ├── formatDate.js
  ├── debounce.js
  └── validators.js
  </code></pre>
                <hr>
                <h3><strong>10.
                    </strong><code><strong>config/</strong></code></h3>
                <p>Holds configuration files for environment-specific
                    settings.</p>
                <p><strong>Example</strong>:</p>
                <pre tabindex="0"><code class="language-java">config/
  ├── apiConfig.js
  └── appConfig.js
  </code></pre>
                <hr>
                <h3><strong>11.
                    </strong><code><strong>App.js</strong></code><strong> and
                    </strong><code><strong>index.js</strong></code></h3>
                <ul>
                    <li><strong>App.js</strong>: The root component of the React app.</li>
                </ul>
                <ul>
                    <li><strong>index.js</strong>: Entry point for the React app,
                        responsible
                        for rendering <code>App.js</code> into the DOM.</li>
                </ul>
                <hr>
                <h3><strong>Best Practices</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Modular Design</strong>: Group related files (e.g., components, hooks, and state) by
                        feature
                        or domain.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Scalability</strong>: Plan the structure to handle future growth without major
                        refactoring.
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Consistency</strong>: Maintain naming conventions and folder organization for easier
                        navigation.</li>
                </ol>
                <p>By adopting this structure, your project becomes
                    easier to scale, debug, and maintain!</p>
            </div>
        </details>
        <details>
            <summary><strong>render, createElement method, and react-dom render method </strong></summary>
            <div class="content">
                <h3><strong>1.
                    </strong><code><strong>render()</strong></code><strong> Method</strong></h3>
                <p>The <code>render()</code> method is commonly
                    associated with React class components and determines what UI will be displayed for a given
                    component.
                </p>
                <hr>
                <h3><strong>Purpose:</strong></h3>
                <p>It returns the <strong>React elements</strong>
                    (virtual DOM representation) that describe what to render on the screen.</p>
                <hr>
                <h3><strong>Key Characteristics:</strong></h3>
                <ul>
                    <li>It is required for class components.</li>
                </ul>
                <ul>
                    <li>It should be a <strong>pure function</strong>: no side effects,
                        always
                        returning the same output for the same input.</li>
                </ul>
                <ul>
                    <li>Must return a single React element (or <code>null</code>).</li>
                </ul>
                <hr>
                <h3><strong>Example:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>"react"</span><span>;</span>
  
  <span>class</span> <span>HelloWorld</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> World<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> HelloWorld<span>;</span>
  </code></pre>
                <p>In this example:</p>
                <ul>
                    <li>The <code>render()</code> method returns a React element, which
                        React
                        uses to update the DOM.</li>
                </ul>
                <ul>
                    <li>React compares the output of <code>render()</code> to the previous
                        output to determine changes (using the Virtual DOM).</li>
                </ul>
                <hr>
                <h3><strong>2.
                    </strong><code><strong>React.createElement()</strong></code><strong> Method</strong></h3>
                <p>The <code>React.createElement()</code> method is a
                    low-level API provided by React to create React elements programmatically. It is typically used
                    internally by React, but you can use it manually.</p>
                <hr>
                <h3><strong>Purpose:</strong></h3>
                <p>It creates a <strong>React element</strong> that
                    represents a DOM node or a custom component. This method is called by JSX under the hood.</p>
                <hr>
                <h3><strong>Syntax:</strong></h3>
                <pre tabindex="0"><code class="language-java">React<span>.</span><span>createElement</span><span>(</span>
  type<span>,</span>          <span>// Type of the element (HTML tag or React component)</span>
  <span>[</span>props<span>]</span><span>,</span>       <span>// An object of props/attributes for the element</span>
  <span>[</span><span>...</span>children<span>]</span>  <span>// Children of the element</span>
  <span>)</span>
  </code></pre>
                <h3><strong>Example Without JSX:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> React<span>.</span><span>createElement</span><span>(</span>
  <span>'h1'</span><span>,</span>
  <span>{</span> <span>className</span><span>:</span> <span>'greeting'</span> <span>}</span><span>,</span>
  <span>'Hello, World!'</span>
  <span>)</span><span>;</span>
  
  console<span>.</span><span>log</span><span>(</span>element<span>)</span><span>;</span>
  </code></pre>
                <p>This outputs:</p>
                <pre tabindex="0"><code class="language-java"><span>{</span>
  <span>type</span><span>:</span> <span>'h1'</span><span>,</span>
  <span>props</span><span>:</span> <span>{</span> <span>className</span><span>:</span> <span>'greeting'</span><span>,</span> <span>children</span><span>:</span> <span>'Hello, World!'</span> <span>}</span><span>,</span>
  <span>key</span><span>:</span> <span>null</span><span>,</span>
  <span>ref</span><span>:</span> <span>null</span>
  <span>}</span>
  </code></pre>
                <h3><strong>Equivalent JSX:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> <span>&lt;</span>h1 className<span>=</span><span>"greeting"</span><span>&gt;</span>Hello<span>,</span> World<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  </code></pre>
                <h3><strong>Key Points:</strong></h3>
                <ul>
                    <li>JSX is syntactic sugar for <code>React.createElement()</code>.</li>
                </ul>
                <ul>
                    <li>Using <code>createElement()</code> manually is uncommon because JSX
                        simplifies writing React code.</li>
                </ul>
                <hr>
                <h3><strong>3.
                    </strong><code><strong>ReactDOM.render()</strong></code><strong> Method</strong></h3>
                <p>The <code>ReactDOM.render()</code> method is
                    responsible for rendering a React application into the DOM.</p>
                <hr>
                <h3><strong>Purpose:</strong></h3>
                <p>It takes a React element (returned from
                    <code>render()</code> or created via <code>createElement()</code>/JSX) and mounts it to a DOM node.
                </p>
                <hr>
                <h3><strong>Syntax:</strong></h3>
                <pre tabindex="0"><code class="language-java">ReactDOM<span>.</span><span>render</span><span>(</span>element<span>,</span> container<span>[</span><span>,</span> callback<span>]</span><span>)</span>
  </code></pre>
                <ul>
                    <li><code><strong>element</strong></code>: The React element to render.
                    </li>
                </ul>
                <ul>
                    <li><code><strong>container</strong></code>: The DOM node where the
                        element
                        will be rendered.</li>
                </ul>
                <ul>
                    <li><code><strong>callback</strong></code> (optional): A function to
                        execute after rendering is complete.</li>
                </ul>
                <hr>
                <h3><strong>Example:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>"react"</span><span>;</span>
  <span>import</span> ReactDOM <span>from</span> <span>"react-dom"</span><span>;</span>
  
  <span>const</span> <span>App</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> React<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  
  ReactDOM<span>.</span><span>render</span><span>(</span><span>&lt;</span>App <span>/</span><span>&gt;</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>"root"</span><span>)</span><span>)</span><span>;</span>
  </code></pre>
                <ul>
                    <li>The React element <code>&lt;App /&gt;</code> is rendered into the
                        DOM
                        node with the <code>id="root"</code>.</li>
                </ul>
                <hr>
                <h3><strong>ReactDOM.render() and Virtual DOM:</strong>
                </h3>
                <ol type="1" start="1">
                    <li>React uses the Virtual DOM to determine changes needed to the real DOM.</li>
                </ol>
                <ol type="1" start="2">
                    <li>The first call to <code>ReactDOM.render()</code> creates the initial DOM structure.</li>
                </ol>
                <ol type="1" start="3">
                    <li>Subsequent calls only update parts of the DOM that changed.</li>
                </ol>
                <hr>
                <h3><strong>Differences Between Them</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Method</strong></td>
                            <td><strong>Purpose</strong></td>
                            <td><strong>Used In</strong></td>
                        </tr>
                        <tr>
                            <td><code>render()</code></td>
                            <td>Determines the React elements (virtual DOM) to render for a
                                component.</td>
                            <td>Class components.</td>
                        </tr>
                        <tr>
                            <td><code>React.createElement()</code></td>
                            <td>Creates React elements programmatically; underlying API for JSX.</td>
                            <td>Internal React logic or advanced use.</td>
                        </tr>
                        <tr>
                            <td><code>ReactDOM.render()</code></td>
                            <td>Renders the React element into a DOM node in the real DOM.</td>
                            <td>Root-level rendering of the app.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Modern React: React 18 and
                    </strong><code><strong>createRoot</strong></code></h3>
                <p>As of React 18, <code>ReactDOM.render()</code> is
                    being replaced by <code>ReactDOM.createRoot()</code> for better performance and support for
                    concurrent
                    features.</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  <span>import</span> ReactDOM <span>from</span> <span>'react-dom/client'</span><span>;</span>
  
  <span>const</span> <span>App</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> React <span>18</span><span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  
  <span>const</span> root <span>=</span> ReactDOM<span>.</span><span>createRoot</span><span>(</span>document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span><span>;</span>
  root<span>.</span><span>render</span><span>(</span><span>&lt;</span>App <span>/</span><span>&gt;</span><span>)</span><span>;</span>
  </code></pre>
                <p>This is now the recommended approach for rendering
                    React applications.</p>
            </div>
        </details>
        <details>
            <summary><strong>React Fragment</strong></summary>
            <div class="content">
                <h3><strong>React Fragment</strong></h3>
                <p>A <strong>React Fragment</strong> is a lightweight
                    wrapper provided by React to group multiple elements without adding an extra node to the DOM. It
                    allows
                    you to return multiple child elements in a component without wrapping them in an unnecessary
                    container
                    element (like a <code>&lt;div&gt;</code>).</p>
                <hr>
                <h3><strong>Why Use React Fragments?</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Avoid Extra DOM Nodes</strong>:<ul>
                            <li>Normally, if you return multiple elements, you need to wrap
                                them in
                                a container (like <code>&lt;div&gt;</code>). This adds unnecessary elements to the DOM,
                                which can
                                affect performance and styling.</li>
                        </ul>
                        <ul>
                            <li>Fragments solve this by allowing grouping without adding an
                                actual
                                DOM node.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Improved Performance</strong>:<ul>
                            <li>Minimizes the number of DOM nodes created, especially
                                useful in
                                deeply nested or large structures.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Cleaner Markup</strong>:<ul>
                            <li>Avoids cluttered DOM trees with unnecessary elements.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>How to Use React Fragments</strong></h3>
                <h3><strong>1. Using
                    </strong><code><strong>&lt;React.Fragment&gt;</strong></code></h3>
                <p>You can wrap multiple elements using
                    <code>&lt;React.Fragment&gt;</code>:
                </p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>FragmentExample</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>React<span>.</span>Fragment<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> World<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>This is a paragraph inside a fragment<span>.</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>React<span>.</span>Fragment<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> FragmentExample<span>;</span>
  </code></pre>
                <p>Output in the DOM:</p>
                <pre tabindex="0"><code class="language-java"><span><span><span>&lt;</span>h1</span><span>&gt;</span></span>Hello, World!<span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>p</span><span>&gt;</span></span>This is a paragraph inside a fragment.<span><span><span>&lt;/</span>p</span><span>&gt;</span></span>
  </code></pre>
                <hr>
                <h3><strong>2. Using the Shorthand Syntax
                        (</strong><code><strong>&lt;&gt; &lt;/&gt;</strong></code><strong>)</strong></h3>
                <p>React provides a shorthand syntax for fragments to
                    make the code cleaner:</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>ShorthandFragmentExample</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> React<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>This is a paragraph using shorthand<span>.</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span><span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ShorthandFragmentExample<span>;</span>
  </code></pre>
                <p>Output in the DOM:</p>
                <pre tabindex="0"><code class="language-java"><span><span><span>&lt;</span>h1</span><span>&gt;</span></span>Hello, React!<span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>p</span><span>&gt;</span></span>This is a paragraph using shorthand.<span><span><span>&lt;/</span>p</span><span>&gt;</span></span>
  </code></pre>
                <blockquote>Note: The shorthand syntax does not
                    support
                    attributes.</blockquote>
                <hr>
                <h3><strong>When to Use Fragments</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Returning Multiple Elements</strong>:<br>Whenever you need to return multiple elements
                        from
                        a component without introducing unnecessary DOM nodes.<br>
                        <pre tabindex="0"><code class="language-java"><span>function</span> <span>ListItems</span><span>(</span><span><span>{</span> items <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>li key<span>=</span><span>{</span>index<span>}</span><span>&gt;</span><span>{</span>item<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span><span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Tables</strong>:<br>Avoid unnecessary <br><code>&lt;div&gt;</code> wrappers inside
                        <code>&lt;table&gt;</code>, <code>&lt;thead&gt;</code>, <code>&lt;tbody&gt;</code>, or
                        <code>&lt;tr&gt;</code> elements.
                        <pre tabindex="0"><code class="language-java"><span>function</span> <span>TableExample</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>table<span>&gt;</span>
      <span>&lt;</span>thead<span>&gt;</span>
        <span>&lt;</span>tr<span>&gt;</span>
          <span>&lt;</span>React<span>.</span>Fragment<span>&gt;</span>
            <span>&lt;</span>th<span>&gt;</span>Name<span>&lt;</span><span>/</span>th<span>&gt;</span>
            <span>&lt;</span>th<span>&gt;</span>Age<span>&lt;</span><span>/</span>th<span>&gt;</span>
          <span>&lt;</span><span>/</span>React<span>.</span>Fragment<span>&gt;</span>
        <span>&lt;</span><span>/</span>tr<span>&gt;</span>
      <span>&lt;</span><span>/</span>thead<span>&gt;</span>
      <span>&lt;</span>tbody<span>&gt;</span>
        <span>&lt;</span>tr<span>&gt;</span>
          <span>&lt;</span>React<span>.</span>Fragment<span>&gt;</span>
            <span>&lt;</span>td<span>&gt;</span>John<span>&lt;</span><span>/</span>td<span>&gt;</span>
            <span>&lt;</span>td<span>&gt;</span><span>25</span><span>&lt;</span><span>/</span>td<span>&gt;</span>
          <span>&lt;</span><span>/</span>React<span>.</span>Fragment<span>&gt;</span>
        <span>&lt;</span><span>/</span>tr<span>&gt;</span>
      <span>&lt;</span><span>/</span>tbody<span>&gt;</span>
    <span>&lt;</span><span>/</span>table<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                        <p>Output:</p>
                        <pre tabindex="0"><code class="language-java"><span><span><span>&lt;</span>table</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>thead</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>tr</span><span>&gt;</span></span>
      <span><span><span>&lt;</span>th</span><span>&gt;</span></span>Name<span><span><span>&lt;/</span>th</span><span>&gt;</span></span>
      <span><span><span>&lt;</span>th</span><span>&gt;</span></span>Age<span><span><span>&lt;/</span>th</span><span>&gt;</span></span>
    <span><span><span>&lt;/</span>tr</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>thead</span><span>&gt;</span></span>
  <span><span><span>&lt;</span>tbody</span><span>&gt;</span></span>
    <span><span><span>&lt;</span>tr</span><span>&gt;</span></span>
      <span><span><span>&lt;</span>td</span><span>&gt;</span></span>John<span><span><span>&lt;/</span>td</span><span>&gt;</span></span>
      <span><span><span>&lt;</span>td</span><span>&gt;</span></span>25<span><span><span>&lt;/</span>td</span><span>&gt;</span></span>
    <span><span><span>&lt;/</span>tr</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>tbody</span><span>&gt;</span></span>
  <span><span><span>&lt;/</span>table</span><span>&gt;</span></span>
  </code></pre>
                    </li>
                </ol>
                <hr>
                <h3><strong>Fragment with Keyed Children</strong></h3>
                <p>If you're working with lists and need to add keys
                    for each child, you can use <code>React.Fragment</code> with the <code>key</code> attribute
                    (shorthand
                    syntax doesn’t support attributes).</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>KeyedFragmentExample</span><span>(</span><span><span>{</span> items <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span><span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>React<span>.</span>Fragment key<span>=</span><span>{</span>item<span>.</span>id<span>}</span><span>&gt;</span>
          <span>&lt;</span>h2<span>&gt;</span><span>{</span>item<span>.</span>title<span>}</span><span>&lt;</span><span>/</span>h2<span>&gt;</span>
          <span>&lt;</span>p<span>&gt;</span><span>{</span>item<span>.</span>description<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
        <span>&lt;</span><span>/</span>React<span>.</span>Fragment<span>&gt;</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span><span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>React Fragment vs
                    </strong><code><strong>&lt;div&gt;</strong></code></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Aspect</strong></td>
                            <td><strong>React Fragment</strong></td>
                            <td><code><strong>&lt;div&gt;</strong></code></td>
                        </tr>
                        <tr>
                            <td><strong>Adds to DOM</strong></td>
                            <td>No</td>
                            <td>Yes</td>
                        </tr>
                        <tr>
                            <td><strong>Affects Styling</strong></td>
                            <td>No</td>
                            <td>Yes (can affect CSS layout)</td>
                        </tr>
                        <tr>
                            <td><strong>Attributes</strong></td>
                            <td>Supports attributes (except shorthand)</td>
                            <td>Supports attributes</td>
                        </tr>
                        <tr>
                            <td><strong>Use Case</strong></td>
                            <td>Grouping without extra DOM nodes</td>
                            <td>Grouping and applying styling/logic.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li>React Fragments provide a clean, efficient way to group child
                        elements.
                    </li>
                </ul>
                <ul>
                    <li>Use the shorthand syntax (<code>&lt;&gt; &lt;/&gt;</code>) for
                        simplicity unless you need attributes like <code>key</code>.</li>
                </ul>
                <ul>
                    <li>They are particularly useful in scenarios where adding extra DOM
                        nodes
                        is unnecessary or problematic, such as in table rows or deeply nested components.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Class and Functional Components</strong></summary>
            <div class="content">
                <p>React provides two ways to create components:
                    <strong>Class Components</strong> and <strong>Functional Components</strong>. Both are used to build
                    user interfaces, but they have differences in syntax, capabilities, and usage.
                </p>
                <hr>
                <h2><strong>Class Components</strong></h2>
                <p>Class components are ES6 classes that extend
                    <code>React.Component</code> and include a <code>render()</code> method to define what UI should be
                    rendered.
                </p>
                <h3><strong>Key Features of Class Components</strong>
                </h3>
                <ol type="1" start="1">
                    <li><strong>Stateful</strong>:<ul>
                            <li>Class components can hold and manage their own state using
                                <code>this.state</code>.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Lifecycle Methods</strong>:<ul>
                            <li>Class components have access to React lifecycle methods
                                like
                                <code>componentDidMount</code>, <code>componentDidUpdate</code>, and
                                <code>componentWillUnmount</code> for managing side effects.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Uses </strong><code><strong>this</strong></code><strong> Keyword</strong>:<ul>
                            <li>The <code>this</code> keyword is required to access props,
                                state,
                                and methods.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>More Boilerplate</strong>:<ul>
                            <li>Requires more code to implement compared to functional
                                components.
                            </li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Example: Class Component</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>class</span> <span>Counter</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span> <span>// Initialize state</span>
  <span>}</span>
  
  <span>// Method to handle increment</span>
  <span>increment</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> <span>count</span><span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Counter<span>;</span>
  </code></pre>
                <hr>
                <h3><strong>Lifecycle Methods in Class
                        Components</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Mounting</strong> (initialization):<ul>
                            <li><code>constructor()</code></li>
                        </ul>
                        <ul>
                            <li><code>componentDidMount()</code></li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Updating</strong> (when state or props change):<ul>
                            <li><code>componentDidUpdate()</code></li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Unmounting</strong> (cleanup):<ul>
                            <li><code>componentWillUnmount()</code></li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h2><strong>Functional Components</strong></h2>
                <p>Functional components are JavaScript functions that
                    accept <code>props</code> and return React elements (UI). Initially, they were stateless, but with
                    the
                    introduction of <strong>React Hooks</strong>, functional components can now manage state and side
                    effects.</p>
                <h3><strong>Key Features of Functional
                        Components</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Stateless or Stateful</strong>:<ul>
                            <li>Initially, functional components were stateless, but
                                <strong>React
                                    Hooks</strong> (like <code>useState</code>, <code>useEffect</code>) enable state and
                                side-effect
                                management.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Simpler Syntax</strong>:<ul>
                            <li>Functional components are simpler and easier to read
                                compared to
                                class components.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>No </strong><code><strong>this</strong></code><strong> Keyword</strong>:<ul>
                            <li>They don’t use <code>this</code>; you directly access props
                                and
                                hooks.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Modern and Recommended</strong>:<ul>
                            <li>Functional components are now the recommended way to build
                                components in React.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Example: Functional Component with
                        Hooks</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// Initialize state using useState</span>
  
  <span>const</span> <span>increment</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// Update state</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Counter<span>;</span>
  </code></pre>
                <hr>
                <h3><strong>Lifecycle Management in Functional
                        Components</strong></h3>
                <p>Using React Hooks, you can manage lifecycle events
                    in functional components:</p>
                <ul>
                    <li><code><strong>useEffect</strong></code> replaces lifecycle methods
                        like
                        <code>componentDidMount</code>, <code>componentDidUpdate</code>, and
                        <code>componentWillUnmount</code>.
                    </li>
                </ul>
                <h3>Example:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Timer</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>seconds<span>,</span> setSeconds<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> interval <span>=</span> <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setSeconds</span><span>(</span><span>(</span><span>prevSeconds</span><span>)</span> <span>=&gt;</span> prevSeconds <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearInterval</span><span>(</span>interval<span>)</span><span>;</span> <span>// Cleanup on unmount</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// Empty dependency array ensures it runs only once</span>
  
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Seconds<span>:</span> <span>{</span>seconds<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Timer<span>;</span>
  </code></pre>
                <hr>
                <h2><strong>Differences Between Class and Functional
                        Components</strong></h2>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Aspect</strong></td>
                            <td><strong>Class Components</strong></td>
                            <td><strong>Functional Components</strong></td>
                        </tr>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>ES6 classes extending <code>React.Component</code>.</td>
                            <td>JavaScript functions returning JSX.</td>
                        </tr>
                        <tr>
                            <td><strong>State Management</strong></td>
                            <td>Use <code>this.state</code> and <code>this.setState()</code>.</td>
                            <td>Use <code>useState</code> hook.</td>
                        </tr>
                        <tr>
                            <td><strong>Lifecycle Methods</strong></td>
                            <td>Use methods like <code>componentDidMount</code>.</td>
                            <td>Use <code>useEffect</code> hook.</td>
                        </tr>
                        <tr>
                            <td><strong>Syntax</strong></td>
                            <td>More verbose and requires <code>render()</code> method.</td>
                            <td>Concise and easier to read.</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Slightly heavier due to class overhead.</td>
                            <td>Lightweight and faster to execute.</td>
                        </tr>
                        <tr>
                            <td><strong>Recommended Usage</strong></td>
                            <td>Legacy or rare cases requiring lifecycle hooks.</td>
                            <td>Preferred and modern approach.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h2><strong>When to Use Each</strong></h2>
                <ul>
                    <li><strong>Class Components</strong>:<ul>
                            <li>Older codebases may rely on class components.</li>
                        </ul>
                        <ul>
                            <li>You might still encounter them in legacy projects.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><strong>Functional Components</strong>:<ul>
                            <li>Modern, simpler, and more efficient.</li>
                        </ul>
                        <ul>
                            <li>Use functional components for all new React projects.
                            </li>
                        </ul>
                    </li>
                </ul>
                <hr>
                <h3><strong>Key Takeaway</strong></h3>
                <p>React Hooks (<code>useState</code>,
                    <code>useEffect</code>, etc.) have made functional components powerful enough to handle state and
                    lifecycle management, reducing the need for class components in most scenarios.
                </p>
            </div>
        </details>
        <details>
            <summary><strong>Components Composing</strong></summary>
            <div class="content">
                <h3><strong>Composing Components in React</strong></h3>
                <p><strong>Composing components</strong> is the process
                    of combining multiple smaller components to build more complex UI elements or entire applications.
                    It’s
                    a fundamental principle in React, which encourages creating reusable, modular components that can be
                    assembled like building blocks.</p>
                <hr>
                <h3><strong>Why Compose Components?</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Reusability</strong>:<ul>
                            <li>Smaller components can be reused across different parts of
                                the
                                application.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Separation of Concerns</strong>:<ul>
                            <li>Each component handles a specific part of the UI or logic,
                                making
                                the code easier to maintain and debug.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Readability</strong>:<ul>
                            <li>Breaking down the UI into logical components improves code
                                clarity.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Scalability</strong>:<ul>
                            <li>Large applications become easier to manage when built with
                                modular
                                components.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Examples of Composing Components</strong>
                </h3>
                <h3><strong>1. Basic Composition</strong></h3>
                <p>You can create components that encapsulate specific
                    logic or UI and combine them.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Header</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>header<span>&gt;</span><span>&lt;</span>h1<span>&gt;</span>Welcome to My App<span>&lt;</span><span>/</span>h1<span>&gt;</span><span>&lt;</span><span>/</span>header<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>Footer</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>footer<span>&gt;</span><span>&lt;</span>p<span>&gt;</span><span>&amp;</span>copy<span>;</span> <span>2024</span> My App<span>&lt;</span><span>/</span>p<span>&gt;</span><span>&lt;</span><span>/</span>footer<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>Header <span>/</span><span>&gt;</span>
      <span>&lt;</span>main<span>&gt;</span>
        <span>&lt;</span>p<span>&gt;</span>This is the main content <span>of</span> the app<span>.</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
      <span>&lt;</span><span>/</span>main<span>&gt;</span>
      <span>&lt;</span>Footer <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>In this example:</p>
                <ul>
                    <li><code>Header</code> and <code>Footer</code> are composed into the
                        <code>App</code> component to form the full structure.
                    </li>
                </ul>
                <hr>
                <h3><strong>2. Passing Props for Dynamic
                        Composition</strong></h3>
                <p>Props allow you to make components reusable and
                    dynamic by passing data to them.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>WelcomeMessage</span><span>(</span><span><span>{</span> name <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>h2<span>&gt;</span>Welcome<span>,</span> <span>{</span>name<span>}</span><span>!</span><span>&lt;</span><span>/</span>h2<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>WelcomeMessage name<span>=</span><span>"Alice"</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>WelcomeMessage name<span>=</span><span>"Bob"</span> <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>Here:</p>
                <ul>
                    <li>The <code>WelcomeMessage</code> component is composed into the
                        <code>App</code> component with different data using props.
                    </li>
                </ul>
                <hr>
                <h3><strong>3. Nesting Components</strong></h3>
                <p>You can compose components hierarchically by nesting
                    them.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>ListItem</span><span>(</span><span><span>{</span> item <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>li<span>&gt;</span><span>{</span>item<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>List</span><span>(</span><span><span>{</span> items <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>ul<span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>ListItem key<span>=</span><span>{</span>index<span>}</span> item<span>=</span><span>{</span>item<span>}</span> <span>/</span><span>&gt;</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span>ul<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> fruits <span>=</span> <span>[</span><span>"Apple"</span><span>,</span> <span>"Banana"</span><span>,</span> <span>"Cherry"</span><span>]</span><span>;</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Fruit List<span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>List items<span>=</span><span>{</span>fruits<span>}</span> <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>Here:</p>
                <ul>
                    <li><code>List</code> is composed of multiple <code>ListItem</code>
                        components, which are rendered dynamically based on data.</li>
                </ul>
                <hr>
                <h3><strong>4. Higher-Order Components (HOC)</strong>
                </h3>
                <p>Higher-Order Components are functions that compose
                    components by enhancing them with additional functionality.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>withGreeting</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>EnhancedComponent</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h2<span>&gt;</span>Hello<span>!</span><span>&lt;</span><span>/</span>h2<span>&gt;</span>
        <span>&lt;</span>WrappedComponent <span>{</span><span>...</span>props<span>}</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>Profile</span><span>(</span><span><span>{</span> name <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>p<span>&gt;</span>This is <span>{</span>name<span>}</span>'s profile<span>.</span><span>&lt;</span><span>/</span>p<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>const</span> EnhancedProfile <span>=</span> <span>withGreeting</span><span>(</span>Profile<span>)</span><span>;</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>EnhancedProfile name<span>=</span><span>"Alice"</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>Here:</p>
                <ul>
                    <li><code>withGreeting</code> is an HOC that composes the
                        <code>Profile</code> component by adding a greeting.
                    </li>
                </ul>
                <hr>
                <h3><strong>5. Composition with Children Prop</strong>
                </h3>
                <p>The <code>children</code> prop allows a parent
                    component to compose child components dynamically.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Card</span><span>(</span><span><span>{</span> children <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div className<span>=</span><span>"card"</span><span>&gt;</span>
      <span>{</span>children<span>}</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>Card<span>&gt;</span>
      <span>&lt;</span>h2<span>&gt;</span>Card Title<span>&lt;</span><span>/</span>h2<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>This is some card content<span>.</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>Card<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>Here:</p>
                <ul>
                    <li>The <code>Card</code> component acts as a wrapper, dynamically
                        rendering whatever is passed as its children.</li>
                </ul>
                <hr>
                <h3><strong>Best Practices for Component
                        Composition</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Break Down the UI</strong>:<ul>
                            <li>Identify parts of the UI that can be isolated into reusable
                                components.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Keep Components Focused</strong>:<ul>
                            <li>Each component should handle a single responsibility.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Avoid Over-Composition</strong>:<ul>
                            <li>Don’t make components too small or granular; balance
                                reusability
                                with readability.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Use Props Effectively</strong>:<ul>
                            <li>Pass data and callbacks as props to make components
                                reusable.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="5">
                    <li><strong>Leverage the Children Prop</strong>:<ul>
                            <li>Use the <code>children</code> prop for flexible and dynamic
                                content
                                composition.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="6">
                    <li><strong>Follow Naming Conventions</strong>:<ul>
                            <li>Use clear, descriptive names for components to improve
                                readability.
                            </li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li><strong>Composing components</strong> is a core concept in React
                        that
                        promotes reusability, modularity, and maintainability.</li>
                </ul>
                <ul>
                    <li>Use props and children to make components dynamic and flexible.
                    </li>
                </ul>
                <ul>
                    <li>Combining smaller components into larger ones creates a clear,
                        scalable
                        structure for your application.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>React JSX</strong></summary>
            <div class="content">
                <h3><strong>What is JSX?</strong></h3>
                <p>JSX (<strong>JavaScript XML</strong>) is a syntax
                    extension for JavaScript commonly used with React to describe what the UI should look like. It
                    allows
                    you to write HTML-like code directly within JavaScript, making it easier to define React components
                    and
                    their structure in a declarative way.</p>
                <hr>
                <h3><strong>Why Use JSX?</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Improved Readability</strong>:<ul>
                            <li>JSX closely resembles HTML, making it more intuitive for
                                developers
                                to create UI components.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Declarative Syntax</strong>:<ul>
                            <li>Provides a clear way to describe what the UI should look
                                like.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Integration with JavaScript</strong>:<ul>
                            <li>You can embed JavaScript expressions directly into JSX
                                using
                                <code>{}</code>.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>React-Friendly</strong>:<ul>
                            <li>JSX is not required to use React, but it simplifies
                                creating React
                                elements compared to the alternative <code>React.createElement()</code>.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>How JSX Works</strong></h3>
                <p>JSX is not valid JavaScript; it needs to be
                    <strong>transpiled</strong> into plain JavaScript using tools like <strong>Babel</strong>. Behind
                    the
                    scenes, JSX is converted to calls to <code>React.createElement()</code>.
                </p>
                <h3><strong>JSX Example:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> World<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  </code></pre>
                <h3><strong>Equivalent JavaScript:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> React<span>.</span><span>createElement</span><span>(</span><span>'h1'</span><span>,</span> <span>null</span><span>,</span> <span>'Hello, World!'</span><span>)</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>JSX Syntax</strong></h3>
                <h3><strong>1. Embedding Expressions</strong></h3>
                <p>You can embed JavaScript expressions within
                    <code>{}</code> in JSX.
                </p>
                <pre tabindex="0"><code class="language-java"><span>const</span> name <span>=</span> <span>"Alice"</span><span>;</span>
  <span>const</span> element <span>=</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> <span>{</span>name<span>}</span><span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  </code></pre>
                <p>Output:</p>
                <pre tabindex="0"><code class="language-java"><span><span><span>&lt;</span>h1</span><span>&gt;</span></span>Hello, Alice!<span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
  </code></pre>
                <hr>
                <h3><strong>2. Attributes in JSX</strong></h3>
                <p>JSX allows attributes to be set on elements, similar
                    to HTML, but some attributes use camelCase instead of kebab-case (e.g., <code>className</code>
                    instead
                    of <code>class</code>).</p>
                <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> <span>&lt;</span>img src<span>=</span><span>"logo.png"</span> alt<span>=</span><span>"Logo"</span> <span>/</span><span>&gt;</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>3. Nested Elements</strong></h3>
                <p>JSX can contain nested elements. Parentheses are
                    commonly used to make the structure more readable.</p>
                <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> <span>(</span>
  <span>&lt;</span>div<span>&gt;</span>
    <span>&lt;</span>h1<span>&gt;</span>Welcome<span>&lt;</span><span>/</span>h1<span>&gt;</span>
    <span>&lt;</span>p<span>&gt;</span>This is a nested element<span>.</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
  <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>4. Components in JSX</strong></h3>
                <p>You can use JSX to include React components like
                    HTML elements.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Welcome</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> <span>{</span>props<span>.</span>name<span>}</span><span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>const</span> element <span>=</span> <span>&lt;</span>Welcome name<span>=</span><span>"Alice"</span> <span>/</span><span>&gt;</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>5. Conditional Rendering</strong></h3>
                <p>Use JavaScript expressions for conditional rendering
                    within JSX.</p>
                <pre tabindex="0"><code class="language-java"><span>const</span> isLoggedIn <span>=</span> <span>true</span><span>;</span>
  <span>const</span> element <span>=</span> <span>(</span>
  <span>&lt;</span>div<span>&gt;</span>
    <span>{</span>isLoggedIn <span>?</span> <span>&lt;</span>h1<span>&gt;</span>Welcome back<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span> <span>:</span> <span>&lt;</span>h1<span>&gt;</span>Please log <span>in</span><span>.</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>}</span>
  <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>6. Looping in JSX</strong></h3>
                <p>You can use JavaScript methods like
                    <code>.map()</code> to render lists.
                </p>
                <pre tabindex="0"><code class="language-java"><span>const</span> items <span>=</span> <span>[</span><span>'Apple'</span><span>,</span> <span>'Banana'</span><span>,</span> <span>'Cherry'</span><span>]</span><span>;</span>
  <span>const</span> list <span>=</span> <span>(</span>
  <span>&lt;</span>ul<span>&gt;</span>
    <span>{</span>items<span>.</span><span>map</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=&gt;</span> <span>(</span>
      <span>&lt;</span>li key<span>=</span><span>{</span>index<span>}</span><span>&gt;</span><span>{</span>item<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>
    <span>)</span><span>)</span><span>}</span>
  <span>&lt;</span><span>/</span>ul<span>&gt;</span>
  <span>)</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>JSX Rules</strong></h3>
                <ol type="1" start="1">
                    <li><strong>JSX Must Have One Parent Element</strong>:<ul>
                            <li>JSX must return a single root element. Use a
                                <code>&lt;div&gt;</code> or a React fragment (<code>&lt;&gt; &lt;/&gt;</code>) to wrap
                                multiple
                                elements.
                            </li>
                        </ul>
                        <pre tabindex="0"><code class="language-java"><span>return</span> <span>(</span>
  <span>&lt;</span><span>&gt;</span>
    <span>&lt;</span>h1<span>&gt;</span>Title<span>&lt;</span><span>/</span>h1<span>&gt;</span>
    <span>&lt;</span>p<span>&gt;</span>Description<span>&lt;</span><span>/</span>p<span>&gt;</span>
  <span>&lt;</span><span>/</span><span>&gt;</span>
  <span>)</span><span>;</span>
  </code></pre>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Self-Closing Tags</strong>:<ul>
                            <li>For elements without children, you must use self-closing
                                tags
                                (e.g., <code>&lt;img /&gt;</code>, <code>&lt;input /&gt;</code>).</li>
                        </ul>
                        <pre tabindex="0"><code class="language-java"><span>const</span> image <span>=</span> <span>&lt;</span>img src<span>=</span><span>"logo.png"</span> alt<span>=</span><span>"Logo"</span> <span>/</span><span>&gt;</span><span>;</span>
  </code></pre>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>JavaScript Reserved Words</strong>:<ul>
                            <li>Some HTML attributes (e.g., <code>class</code>,
                                <code>for</code>)
                                are reserved in JavaScript. In JSX:<ul>
                                    <li>Use <code>className</code> instead of
                                        <code>class</code>.
                                    </li>
                                </ul>
                                <ul>
                                    <li>Use <code>htmlFor</code> instead of
                                        <code>for</code>.
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <pre tabindex="0"><code class="language-java"><span>const</span> element <span>=</span> <span>&lt;</span>label htmlFor<span>=</span><span>"inputId"</span><span>&gt;</span>Label<span>&lt;</span><span>/</span>label<span>&gt;</span><span>;</span>
  </code></pre>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>JavaScript Expressions Only</strong>:<ul>
                            <li>Only JavaScript expressions (not statements like
                                <code>if</code> or
                                <code>for</code>) can be used inside <code>{}</code>.
                            </li>
                        </ul>
                        <pre tabindex="0"><code class="language-java"><span>const</span> greeting <span>=</span> isLoggedIn <span>?</span> <span>'Hello!'</span> <span>:</span> <span>'Please log in.'</span><span>;</span>
  </code></pre>
                    </li>
                </ol>
                <hr>
                <h3><strong>JSX vs HTML</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Feature</strong></td>
                            <td><strong>JSX</strong></td>
                            <td><strong>HTML</strong></td>
                        </tr>
                        <tr>
                            <td>Syntax</td>
                            <td>Allows embedding JavaScript expressions.</td>
                            <td>Static, no JavaScript support.</td>
                        </tr>
                        <tr>
                            <td>Attributes</td>
                            <td>camelCase (<code>className</code>, <code>htmlFor</code>).</td>
                            <td>kebab-case (<code>class</code>, <code>for</code>).</td>
                        </tr>
                        <tr>
                            <td>Dynamic Content</td>
                            <td>Can use <code>{}</code> for dynamic data.</td>
                            <td>Requires JavaScript separately.</td>
                        </tr>
                        <tr>
                            <td>Component Support</td>
                            <td>Includes React components.</td>
                            <td>No component concept.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Advantages of JSX</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Cleaner Code</strong>:<ul>
                            <li>Combines HTML-like syntax and JavaScript into one file.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Dynamic Content</strong>:<ul>
                            <li>Easy to inject dynamic values and expressions.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Integration with React</strong>:<ul>
                            <li>Simplifies React element creation compared to
                                <code>React.createElement()</code>.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Debugging</strong>:<ul>
                            <li>Provides descriptive error messages if JSX is improperly
                                formatted.
                            </li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Disadvantages of JSX</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Learning Curve</strong>:<ul>
                            <li>Developers must learn JSX syntax in addition to JavaScript.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Tooling Dependency</strong>:<ul>
                            <li>Requires a transpiler like Babel to convert JSX to plain
                                JavaScript.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Key Takeaway</strong></h3>
                <p>JSX is a powerful feature in React that simplifies
                    writing user interfaces by blending HTML-like syntax with JavaScript. While it requires
                    preprocessing,
                    its advantages in terms of readability, modularity, and dynamic capabilities make it the preferred
                    choice for React development.</p>
            </div>
        </details>
        <details>
            <summary><strong>React Props</strong></summary>
            <div class="content">
                <h3><strong>Props in React</strong></h3>
                <p>In React, <strong>props</strong> (short for
                    <em>properties</em>) are a way to pass data from a parent component to a child component. Props are
                    used
                    to configure components, making them dynamic and reusable.
                </p>
                <hr>
                <h3><strong>Key Features of Props</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Read-Only</strong>:<ul>
                            <li>Props are immutable; a child component cannot modify props
                                directly.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Unidirectional Data Flow</strong>:<ul>
                            <li>Props are passed <strong>down</strong> the component tree
                                from
                                parent to child.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Reusable Components</strong>:<ul>
                            <li>Props allow components to be used in different contexts
                                with
                                different data.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>JavaScript Objects</strong>:<ul>
                            <li>Props are passed as an object, and you can access their
                                values
                                using <code>props.propertyName</code>.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>How Props Work</strong></h3>
                <h3><strong>Passing Props from Parent to Child</strong>
                </h3>
                <p>The parent component provides the data, and the
                    child component receives it as an argument.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Greeting</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> <span>{</span>props<span>.</span>name<span>}</span><span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>Greeting name<span>=</span><span>"Alice"</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>Here:</p>
                <ul>
                    <li><code>name="Alice"</code> is passed as a prop from the
                        <code>App</code>
                        component to the <code>Greeting</code> component.
                    </li>
                </ul>
                <ul>
                    <li>Inside <code>Greeting</code>, you access the <code>name</code> prop
                        using <code>props.name</code>.</li>
                </ul>
                <hr>
                <h3><strong>Props Example</strong></h3>
                <h3><strong>1. Passing Multiple Props</strong></h3>
                <p>You can pass multiple props by including more
                    attributes in the child component's JSX.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>UserInfo</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>props<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Age<span>:</span> <span>{</span>props<span>.</span>age<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>UserInfo name<span>=</span><span>"Alice"</span> age<span>=</span><span>{</span><span>25</span><span>}</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>2. Destructuring Props</strong></h3>
                <p>For cleaner code, you can destructure props in the
                    function parameter.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>UserInfo</span><span>(</span><span><span>{</span> name<span>,</span> age <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>name<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Age<span>:</span> <span>{</span>age<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>3. Default Props</strong></h3>
                <p>You can set default values for props using the
                    <code>defaultProps</code> property.
                </p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Greeting</span><span>(</span><span><span>{</span> name <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> <span>{</span>name<span>}</span><span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  Greeting<span>.</span>defaultProps <span>=</span> <span>{</span>
  <span>name</span><span>:</span> <span>"Guest"</span><span>,</span>
  <span>}</span><span>;</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>Greeting <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                <p>Output:</p>
                <pre tabindex="0"><code class="language-java"><span><span><span>&lt;</span>h1</span><span>&gt;</span></span>Hello, Guest!<span><span><span>&lt;/</span>h1</span><span>&gt;</span></span>
  </code></pre>
                <hr>
                <h3><strong>4. Prop Validation</strong></h3>
                <p>React provides the <code>prop-types</code> package
                    to validate the props passed to a component.</p>
                <pre tabindex="0"><code class="language-java">npm install prop-types
  </code></pre>
                <p>Usage:</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> PropTypes <span>from</span> <span>'prop-types'</span><span>;</span>
  
  <span>function</span> <span>UserInfo</span><span>(</span><span><span>{</span> name<span>,</span> age <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>name<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Age<span>:</span> <span>{</span>age<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  UserInfo<span>.</span>propTypes <span>=</span> <span>{</span>
  <span>name</span><span>:</span> PropTypes<span>.</span>string<span>.</span>isRequired<span>,</span>
  <span>age</span><span>:</span> PropTypes<span>.</span>number<span>,</span>
  <span>}</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>5. Passing Functions as Props</strong></h3>
                <p>Props can also be used to pass functions from a
                    parent to a child.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Button</span><span>(</span><span><span>{</span> handleClick <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>button onClick<span>=</span><span>{</span>handleClick<span>}</span><span>&gt;</span>Click Me<span>&lt;</span><span>/</span>button<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>alertMessage</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>alert</span><span>(</span><span>"Button clicked!"</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span>Button handleClick<span>=</span><span>{</span>alertMessage<span>}</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Props vs State</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Aspect</strong></td>
                            <td><strong>Props</strong></td>
                            <td><strong>State</strong></td>
                        </tr>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Data passed from parent to child components.</td>
                            <td>Data managed internally by a component.</td>
                        </tr>
                        <tr>
                            <td><strong>Mutability</strong></td>
                            <td>Immutable (read-only).</td>
                            <td>Mutable (can be updated using <code>setState</code> or
                                <code>useState</code>).
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Accessible to child components.</td>
                            <td>Local to the component where it is defined.</td>
                        </tr>
                        <tr>
                            <td><strong>Responsibility</strong></td>
                            <td>Controlled by the parent component.</td>
                            <td>Managed by the component itself.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Practical Use Cases for Props</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Dynamic Components</strong>:<ul>
                            <li>Pass data (like user information) to customize a reusable
                                component.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Communication from Parent to Child</strong>:<ul>
                            <li>Share data and configuration settings with child
                                components.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Passing Event Handlers</strong>:<ul>
                            <li>Enable child components to trigger actions in the parent.
                            </li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li>Props enable components to be <strong>flexible</strong>,
                        <strong>customizable</strong>, and <strong>reusable</strong>.
                    </li>
                </ul>
                <ul>
                    <li>They follow the principle of <strong>unidirectional data
                            flow</strong>
                        in React.</li>
                </ul>
                <ul>
                    <li>Use props for passing data, configuration, or callbacks to child
                        components, while keeping them immutable.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>React State</strong></summary>
            <div class="content">
                <h3><strong>State in React</strong></h3>
                <p><strong>State</strong> in React is an object used to
                    store dynamic, mutable data within a component. It determines how the component behaves and what it
                    renders. Unlike props (which are read-only), <strong>state</strong> can be changed within the
                    component,
                    making it an essential feature for creating interactive and dynamic UIs.</p>
                <hr>
                <h3><strong>Key Characteristics of State</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Mutable</strong>:<ul>
                            <li>State can be updated using methods like
                                <code>setState</code> (in
                                class components) or <code>useState</code> (in functional components).
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Local to the Component</strong>:<ul>
                            <li>State is encapsulated within the component where it is
                                defined and
                                cannot be directly accessed by other components.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Reactivity</strong>:<ul>
                            <li>When state changes, the component re-renders automatically
                                to
                                reflect the updated state.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Managed by the Component</strong>:<ul>
                            <li>Unlike props, state is owned and controlled by the
                                component
                                itself.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Using State in React</strong></h3>
                <h3><strong>1. State in Class Components</strong></h3>
                <p>In class components, state is defined as an object
                    inside the <code>constructor</code> and updated using the <code>setState</code> method.</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>class</span> <span>Counter</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span> <span>// Initialize state</span>
  <span>}</span>
  
  <span>// Method to update state</span>
  <span>increment</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> <span>count</span><span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Counter<span>;</span>
  </code></pre>
                <hr>
                <h3><strong>2. State in Functional Components with
                        Hooks</strong></h3>
                <p>React’s <code>useState</code> hook allows functional
                    components to have state.</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span> <span>// Initialize state</span>
  
  <span>const</span> <span>increment</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// Update state</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Counter<span>;</span>
  </code></pre>
                <hr>
                <h3><strong>Updating State</strong></h3>
                <h3><strong>1. Updating State in Class
                        Components</strong></h3>
                <ul>
                    <li><code><strong>setState</strong></code> merges the new state with
                        the
                        existing state.</li>
                </ul>
                <ul>
                    <li>Updates can be asynchronous, so relying on <code>this.state</code>
                        immediately after <code>setState</code> may lead to unexpected results. Use the callback form of
                        <code>setState</code> to avoid this issue.
                    </li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>this</span><span>.</span><span>setState</span><span>(</span><span>(</span><span>prevState</span><span>)</span> <span>=&gt;</span> <span>(</span><span>{</span> <span>count</span><span>:</span> prevState<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>)</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>2. Updating State in Functional
                        Components</strong></h3>
                <ul>
                    <li>Use the updater function of <code>setState</code> when the new
                        state
                        depends on the previous state.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>setCount</span><span>(</span><span>(</span><span>prevCount</span><span>)</span> <span>=&gt;</span> prevCount <span>+</span> <span>1</span><span>)</span><span>;</span>
  </code></pre>
                <hr>
                <h3><strong>Multiple State Variables</strong></h3>
                <p>With <code>useState</code>, you can have multiple
                    independent pieces of state.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>UserInfo</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>name<span>,</span> setName<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span>age<span>,</span> setAge<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>input placeholder<span>=</span><span>"Name"</span> onChange<span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>setName</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>input placeholder<span>=</span><span>"Age"</span> type<span>=</span><span>"number"</span> onChange<span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>setAge</span><span>(</span><span>+</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>
        <span>{</span>name<span>}</span> is <span>{</span>age<span>}</span> years old<span>.</span>
      <span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>State vs Props</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Aspect</strong></td>
                            <td><strong>State</strong></td>
                            <td><strong>Props</strong></td>
                        </tr>
                        <tr>
                            <td><strong>Definition</strong></td>
                            <td>Data managed internally by the component.</td>
                            <td>Data passed from parent to child components.</td>
                        </tr>
                        <tr>
                            <td><strong>Mutability</strong></td>
                            <td>Mutable (can be updated by the component).</td>
                            <td>Immutable (read-only).</td>
                        </tr>
                        <tr>
                            <td><strong>Scope</strong></td>
                            <td>Local to the component.</td>
                            <td>Accessible to child components.</td>
                        </tr>
                        <tr>
                            <td><strong>Responsibility</strong></td>
                            <td>Managed by the component itself.</td>
                            <td>Controlled by the parent component.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>When to Use State</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Interactive Components</strong>:<ul>
                            <li>Components that need to respond to user input (e.g., forms,
                                counters).</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Dynamic Content</strong>:<ul>
                            <li>Components whose content changes over time or based on user
                                interaction.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Local Data Management</strong>:<ul>
                            <li>Temporary data that doesn’t need to be shared across
                                components
                                (e.g., toggling a dropdown menu).</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>State Lifecycle in Class
                        Components</strong></h3>
                <h3><strong>1. Initialization</strong>:</h3>
                <p>State is initialized in the constructor.</p>
                <h3><strong>2. Update</strong>:</h3>
                <p>State is updated using <code>setState</code>, which
                    triggers a re-render.</p>
                <h3><strong>3. Unmounting</strong>:</h3>
                <p>State is cleared when the component is unmounted
                    from the DOM.</p>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li><strong>State is mutable and local to the component.</strong></li>
                </ul>
                <ul>
                    <li>Use <code><strong>useState</strong></code> for functional
                        components
                        and <code><strong>this.setState</strong></code> for class components.</li>
                </ul>
                <ul>
                    <li><strong>Reactivity</strong> in state ensures the UI stays in sync
                        with
                        the data.</li>
                </ul>
                <ul>
                    <li>Keep state minimal and focused; only store what is necessary for
                        the
                        component’s functionality.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Phases of Component</strong></summary>
            <div class="content">
                <h3><strong>Lifecycle Phases of a React
                        Component</strong></h3>
                <p>React components go through several phases during
                    their existence: <strong>mounting</strong>, <strong>updating</strong>, and
                    <strong>unmounting</strong>.
                    These phases are important because they provide hooks for you to run specific logic at certain
                    points in
                    the component's lifecycle.
                </p>
                <p>In React, lifecycle methods are primarily associated
                    with <strong>class components</strong>, while <strong>functional components</strong> use
                    <strong>React
                        hooks</strong> like <code>useEffect</code> to handle similar functionality.
                </p>
                <h3><strong>1. Mounting Phase (Component
                        Creation)</strong></h3>
                <p>This is the phase when the component is being
                    created and inserted into the DOM. The component goes through the following lifecycle methods (for
                    class
                    components):</p>
                <h3><strong>Mounting Lifecycle Methods in Class
                        Components:</strong></h3>
                <ul>
                    <li><code><strong>constructor()</strong></code>:<ul>
                            <li>This is called when the component is created. It's used
                                for
                                initializing the state and binding event handlers.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>static getDerivedStateFromProps()</strong></code>:<ul>
                            <li>Called before every render, both during the mounting and
                                updating
                                phases. It allows you to update the state based on props.</li>
                        </ul>
                        <ul>
                            <li>This is a <strong>static method</strong>, so it doesn’t
                                have
                                access to <code>this</code>.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>render()</strong></code>:<ul>
                            <li>The only required method in a class component. It returns
                                the JSX
                                that defines what should be rendered to the DOM.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>componentDidMount()</strong></code>:<ul>
                            <li>Called once, immediately after the component has been
                                inserted
                                into the DOM. It's ideal for making network requests, setting up subscriptions, or
                                initializing
                                third-party libraries.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Example (Class Component - Mounting
                        Phase):</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Component mounted!'</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>div<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>2. Updating Phase (When Props or State
                        Change)</strong></h3>
                <p>The updating phase occurs when a component’s state
                    or props change, causing a re-render. This phase is triggered by the following:</p>
                <ul>
                    <li><strong>State updates</strong> using <code>setState()</code> in
                        class
                        components or <code>useState()</code> in functional components.</li>
                </ul>
                <ul>
                    <li><strong>Props changes</strong> due to changes in the parent
                        component.
                    </li>
                </ul>
                <h3><strong>Updating Lifecycle Methods in Class
                        Components:</strong></h3>
                <ul>
                    <li><code><strong>static getDerivedStateFromProps()</strong></code>
                        (also
                        called during updates):<ul>
                            <li>This method can update the state based on changes in
                                props.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>shouldComponentUpdate()</strong></code>:<ul>
                            <li>This is called before the render method and allows you to
                                optimize performance by preventing unnecessary re-renders. It receives the next set of
                                <code>props</code> and <code>state</code> and returns <code>true</code> or
                                <code>false</code>.
                            </li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>render()</strong></code>:<ul>
                            <li>The component will re-render with the new state or props.
                            </li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>getSnapshotBeforeUpdate()</strong></code>:<ul>
                            <li>Called right before the DOM is updated, providing a way
                                to
                                capture information (like scroll position) from the DOM before React makes changes.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><code><strong>componentDidUpdate()</strong></code>:<ul>
                            <li>Called after the update has been made to the DOM. It is
                                ideal for
                                operations like network requests or interacting with the DOM after updates.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Example (Class Component - Updating
                        Phase):</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextState<span>.</span>count <span>&gt;</span> <span>5</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>5</span> <span>}</span><span>;</span> <span>// Prevent count from going beyond 5</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span> <span>// Return null to indicate no state change</span>
  <span>}</span>
  
  <span>componentDidUpdate</span><span>(</span><span>prevProps<span>,</span> prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prevState<span>.</span>count <span>!==</span> <span>this</span><span>.</span>state<span>.</span>count<span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Component updated!'</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  
  <span>increment</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> <span>count</span><span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>Count</span><span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>3. Unmounting Phase (Component
                        Removal)</strong></h3>
                <p>This is the phase when the component is removed from
                    the DOM. This phase is important for cleaning up resources like network requests, timers, and
                    subscriptions that were set up during the component's lifecycle.</p>
                <h3><strong>Unmounting Lifecycle Method in Class
                        Components:</strong></h3>
                <ul>
                    <li><code><strong>componentWillUnmount()</strong></code>:<ul>
                            <li>This method is called right before the component is
                                removed from
                                the DOM. It’s used for cleanup tasks such as invalidating timers, canceling network
                                requests, or
                                clearing subscriptions.</li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Example (Class Component - Unmounting
                        Phase):</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>timer <span>=</span> <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> console<span>.</span><span>log</span><span>(</span><span>'Timer running'</span><span>)</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>clearInterval</span><span>(</span><span>this</span><span>.</span>timer<span>)</span><span>;</span> <span>// Clean up the timer when the component is unmounted</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>div<span>&gt;</span>Component <span>with</span> a timer<span>!</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Functional Components and Lifecycle
                        Hooks</strong></h3>
                <p>In <strong>functional components</strong>, lifecycle
                    methods from class components are handled by React hooks. The most commonly used hook for managing
                    component lifecycle in functional components is <code>useEffect</code>.</p>
                <h3><code><strong>useEffect</strong></code><strong>
                        Hook (Functional Component)</strong></h3>
                <ul>
                    <li><code><strong>useEffect</strong></code> can be used for operations
                        like
                        data fetching, setting up subscriptions, and manually updating the DOM.</li>
                </ul>
                <ul>
                    <li>It behaves similarly to <code>componentDidMount</code>,
                        <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> combined.
                    </li>
                </ul>
                <ul>
                    <li>The <strong>first argument</strong> is a function that will run
                        after
                        the component renders, and the <strong>second argument</strong> is a dependency array that
                        determines
                        when the effect runs.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>// useEffect runs after the component mounts or updates</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Component mounted or updated!'</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Cleanup before unmount or when state changes'</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>count<span>]</span><span>)</span><span>;</span> <span>// The effect runs when `count` changes</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>Count</span><span>:</span> <span>{</span>count<span>}</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <p>In this example:</p>
                <ul>
                    <li>The <code>useEffect</code> hook logs a message when the component
                        mounts or updates.</li>
                </ul>
                <ul>
                    <li>The <strong>cleanup function</strong> is executed before the
                        component
                        is unmounted or before the effect re-runs (when the <code>count</code> state changes).</li>
                </ul>
                <hr>
                <h3><strong>Summary of Lifecycle Phases</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Mounting Phase</strong>:<ul>
                            <li>The component is being created and inserted into the DOM.
                            </li>
                        </ul>
                        <ul>
                            <li>Methods: <code>constructor()</code>,
                                <code>getDerivedStateFromProps()</code>, <code>render()</code>,
                                <code>componentDidMount()</code>.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Updating Phase</strong>:<ul>
                            <li>The component’s state or props change, and the component
                                re-renders.</li>
                        </ul>
                        <ul>
                            <li>Methods: <code>getDerivedStateFromProps()</code>,
                                <code>shouldComponentUpdate()</code>, <code>render()</code>,
                                <code>getSnapshotBeforeUpdate()</code>, <code>componentDidUpdate()</code>.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Unmounting Phase</strong>:<ul>
                            <li>The component is being removed from the DOM, and you should
                                clean
                                up any resources.</li>
                        </ul>
                        <ul>
                            <li>Method: <code>componentWillUnmount()</code>.</li>
                        </ul>
                    </li>
                </ol>
                <p>For <strong>functional components</strong>, these
                    lifecycle methods are handled using the <code>useEffect</code> hook, which provides an efficient way
                    to
                    run code on mount, update, and unmount.</p>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li>The lifecycle of a React component can be broken down into
                        <strong>mounting</strong>, <strong>updating</strong>, and <strong>unmounting</strong> phases.
                    </li>
                </ul>
                <ul>
                    <li><strong>Class components</strong> use specific lifecycle methods
                        for
                        each phase, while <strong>functional components</strong> use hooks like <code>useEffect</code>.
                    </li>
                </ul>
                <ul>
                    <li>React’s lifecycle methods help manage resources, optimize
                        performance,
                        and perform side effects like data fetching or DOM manipulation.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Life Cycle Method</strong></summary>
            <div class="content">
                <h3><strong>Lifecycle Methods in React (Class
                        Components)</strong></h3>
                <p>In React, lifecycle methods are special methods that
                    get called at specific points in the lifecycle of a component, from when it's created and inserted
                    into
                    the DOM, to when it updates, and finally when it's removed from the DOM.</p>
                <p>Lifecycle methods are specific to <strong>class
                        components</strong>. With the introduction of <strong>functional components</strong> and
                    <strong>React
                        hooks</strong> (like <code>useEffect</code>), many lifecycle tasks can now be handled in
                    functional
                    components. However, lifecycle methods are still essential for understanding class component
                    behavior.
                </p>
                <h3><strong>Lifecycle Phases in React</strong></h3>
                <p>React components have three main lifecycle phases:
                </p>
                <ol type="1" start="1">
                    <li><strong>Mounting</strong>: When the component is created and inserted into the DOM.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Updating</strong>: When the component's state or props change.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Unmounting</strong>: When the component is removed from the DOM.</li>
                </ol>
                <p>Each phase has a set of <strong>lifecycle
                        methods</strong> that are called at specific times.</p>
                <hr>
                <h3><strong>Mounting Phase</strong> (When the component
                    is being created and inserted into the DOM)</h3>
                <p>In the <strong>mounting phase</strong>, the
                    following lifecycle methods are called:</p>
                <h3>1.
                    <code><strong>constructor(props)</strong></code>:
                </h3>
                <ul>
                    <li>This is the first method called when the component is created.</li>
                </ul>
                <ul>
                    <li>It's used for initializing the state and binding event handlers.
                    </li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
  <span>super</span><span>(</span>props<span>)</span><span>;</span> <span>// Initialize the parent class</span>
  <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span> <span>// Set initial state</span>
  <span>}</span>
  </code></pre>
                <h3>2.
                    <code><strong>static getDerivedStateFromProps(nextProps, nextState)</strong></code>:
                </h3>
                <ul>
                    <li>This method is called <strong>before every render</strong>, both
                        during
                        mounting and updating.</li>
                </ul>
                <ul>
                    <li>It allows the component to update the state based on changes in the
                        props. It returns an object to update the state or <code>null</code> if no changes are needed.
                    </li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>nextState<span>.</span>count <span>&gt;</span> <span>5</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>5</span> <span>}</span><span>;</span> <span>// Limit the count to 5</span>
  <span>}</span>
  <span>return</span> <span>null</span><span>;</span> <span>// No state changes</span>
  <span>}</span>
  </code></pre>
                <h3>3. <code><strong>render()</strong></code>:</h3>
                <ul>
                    <li>The only required method in a class component.</li>
                </ul>
                <ul>
                    <li>It returns the JSX that will be rendered to the DOM.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>render</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>div<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                <h3>4.
                    <code><strong>componentDidMount()</strong></code>:
                </h3>
                <ul>
                    <li>Called <strong>once</strong>, immediately after the component is
                        inserted into the DOM.</li>
                </ul>
                <ul>
                    <li>This is the place to make network requests, set up subscriptions,
                        or
                        interact with the DOM.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Component has mounted'</span><span>)</span><span>;</span>
  <span>// Network requests or initializing third-party libraries can be done here</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Updating Phase</strong> (When state or
                    props change)</h3>
                <p>The <strong>updating phase</strong> occurs when a
                    component's state or props change, leading to a re-render. The following methods are called during
                    this
                    phase:</p>
                <h3>1.
                    <code><strong>static getDerivedStateFromProps(nextProps, nextState)</strong></code>:
                </h3>
                <ul>
                    <li>This method is also called during the <strong>updating
                            phase</strong>
                        when props or state change.</li>
                </ul>
                <ul>
                    <li>It allows you to adjust the state based on changes in the incoming
                        props.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
  <span>// Logic for updating state based on new props</span>
  <span>return</span> <span>null</span><span>;</span>
  <span>}</span>
  </code></pre>
                <h3>2.
                    <code><strong>shouldComponentUpdate(nextProps, nextState)</strong></code>:
                </h3>
                <ul>
                    <li>This method determines if the component should update based on
                        changes
                        to <strong>props</strong> or <strong>state</strong>.</li>
                </ul>
                <ul>
                    <li>It receives <code>nextProps</code> and <code>nextState</code> and
                        returns <code>true</code> (to allow the update) or <code>false</code> (to prevent re-rendering).
                    </li>
                </ul>
                <ul>
                    <li>This method is useful for optimizing performance by preventing
                        unnecessary re-renders.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>shouldComponentUpdate</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>nextState<span>.</span>count <span>===</span> <span>this</span><span>.</span>state<span>.</span>count<span>)</span> <span>{</span>
    <span>return</span> <span>false</span><span>;</span> <span>// Skip re-render if state count hasn't changed</span>
  <span>}</span>
  <span>return</span> <span>true</span><span>;</span> <span>// Re-render if count has changed</span>
  <span>}</span>
  </code></pre>
                <h3>3. <code><strong>render()</strong></code>:</h3>
                <ul>
                    <li>The <code>render()</code> method will always be called again during
                        the
                        updating phase if the component re-renders due to a state or prop change.</li>
                </ul>
                <h3>4.
                    <code><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></code>:
                </h3>
                <ul>
                    <li>This method is called <strong>right before</strong> the DOM is
                        updated,
                        allowing you to capture information (such as scroll position) before React makes the changes.
                    </li>
                </ul>
                <ul>
                    <li>The value returned by this method will be passed to
                        <code>componentDidUpdate()</code>.
                    </li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>getSnapshotBeforeUpdate</span><span>(</span><span>prevProps<span>,</span> prevState</span><span>)</span> <span>{</span>
  <span>// Capture scroll position before the update</span>
  <span>return</span> document<span>.</span><span>getElementById</span><span>(</span><span>'scrollable'</span><span>)</span><span>.</span>scrollTop<span>;</span>
  <span>}</span>
  </code></pre>
                <h3>5.
                    <code><strong>componentDidUpdate(prevProps, prevState, snapshot)</strong></code>:
                </h3>
                <ul>
                    <li>Called <strong>after</strong> the component updates the DOM with
                        new
                        props or state.</li>
                </ul>
                <ul>
                    <li>The <code>prevProps</code> and <code>prevState</code> arguments
                        allow
                        you to compare the previous and current values, while <code>snapshot</code> is the value
                        returned from
                        <code>getSnapshotBeforeUpdate()</code>.
                    </li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>componentDidUpdate</span><span>(</span><span>prevProps<span>,</span> prevState<span>,</span> snapshot</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Component did update'</span><span>)</span><span>;</span>
  <span>if</span> <span>(</span>prevState<span>.</span>count <span>!==</span> <span>this</span><span>.</span>state<span>.</span>count<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Count changed'</span><span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Unmounting Phase</strong> (When the
                    component is being removed from the DOM)</h3>
                <p>In the <strong>unmounting phase</strong>, the
                    following lifecycle method is called:</p>
                <h3>1.
                    <code><strong>componentWillUnmount()</strong></code>:
                </h3>
                <ul>
                    <li>This method is called <strong>just before</strong> the component is
                        removed from the DOM.</li>
                </ul>
                <ul>
                    <li>It's used to clean up any resources like cancelling network
                        requests,
                        clearing timers, or unsubscribing from events.</li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Component will unmount'</span><span>)</span><span>;</span>
  <span>clearInterval</span><span>(</span><span>this</span><span>.</span>timer<span>)</span><span>;</span> <span>// Clear any active timers</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Summary of Lifecycle Methods in Class
                        Components</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Phase</strong></td>
                            <td><strong>Method</strong></td>
                            <td><strong>Description</strong></td>
                        </tr>
                        <tr>
                            <td><strong>Mounting</strong></td>
                            <td><code>constructor()</code></td>
                            <td>Initialize state and bind methods.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>getDerivedStateFromProps()</code></td>
                            <td>Update state based on props before every render.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>render()</code></td>
                            <td>Render the JSX output to the DOM.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>componentDidMount()</code></td>
                            <td>Run side effects, like fetching data, after mount.</td>
                        </tr>
                        <tr>
                            <td><strong>Updating</strong></td>
                            <td><code>getDerivedStateFromProps()</code></td>
                            <td>Update state based on new props or state.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>shouldComponentUpdate()</code></td>
                            <td>Optimize re-renders by controlling whether the component should
                                update.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>render()</code></td>
                            <td>Re-render based on state or props changes.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>getSnapshotBeforeUpdate()</code></td>
                            <td>Capture snapshot data before DOM update.</td>
                        </tr>
                        <tr>
                            <td></td>
                            <td><code>componentDidUpdate()</code></td>
                            <td>Handle side effects after the component updates.</td>
                        </tr>
                        <tr>
                            <td><strong>Unmounting</strong></td>
                            <td><code>componentWillUnmount()</code></td>
                            <td>Clean up resources before the component is removed from the DOM.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Lifecycle Methods in Functional Components
                        (React Hooks)</strong></h3>
                <p>With the introduction of <strong>functional
                        components</strong> and <strong>React hooks</strong>, many of the lifecycle methods in class
                    components can now be handled using the <code>useEffect</code> hook.</p>
                <h3><code><strong>useEffect</strong></code><strong>
                        Hook</strong>:</h3>
                <ul>
                    <li>The <code>useEffect</code> hook can mimic most of the lifecycle
                        methods
                        in functional components:<ul>
                            <li><code><strong>componentDidMount()</strong></code>: Run
                                once after
                                the initial render.</li>
                        </ul>
                        <ul>
                            <li><code><strong>componentDidUpdate()</strong></code>: Run
                                after
                                every render when the component updates.</li>
                        </ul>
                        <ul>
                            <li><code><strong>componentWillUnmount()</strong></code>:
                                Clean up
                                resources before the component unmounts.</li>
                        </ul>
                    </li>
                </ul>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>// Mimic componentDidMount and componentDidUpdate</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Component mounted or updated'</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Component will unmount'</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>count<span>]</span><span>)</span><span>;</span> <span>// Effect runs when `count` changes</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Key Takeaways:</strong></h3>
                <ul>
                    <li>Lifecycle methods are primarily used in <strong>class
                            components</strong> to control the component's behavior at different stages.</li>
                </ul>
                <ul>
                    <li>React provides lifecycle methods for each of the three phases:
                        <strong>mounting</strong>, <strong>updating</strong>, and <strong>unmounting</strong>.
                    </li>
                </ul>
                <ul>
                    <li><strong>Functional components</strong> use the
                        <code>useEffect</code>
                        hook to perform similar tasks as the class component lifecycle methods.
                    </li>
                </ul>
                <ul>
                    <li>Understanding these methods helps you control side effects,
                        optimize
                        rendering, and clean up resources.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Mounting</strong> </summary>
            <div class="content">
                <h3><strong>Mounting in React (Detailed
                        Explanation)</strong></h3>
                <p>In React, <strong>mounting</strong> refers to the
                    process of creating a new component instance and inserting it into the <strong>DOM</strong>. During
                    this
                    phase, React goes through several lifecycle methods in class components or uses <strong>React
                        hooks</strong> in functional components to perform tasks like initialization, fetching data, and
                    setting up subscriptions.</p>
                <p>Mounting is the first phase in the <strong>component
                        lifecycle</strong> in React. Understanding this phase is essential because it allows you to
                    perform
                    tasks when a component is created and before it's displayed to the user.</p>
                <hr>
                <h3><strong>Mounting in Class Components</strong></h3>
                <p>When a class component is created, React goes
                    through the following sequence of lifecycle methods during the mounting phase:</p>
                <ol type="1" start="1">
                    <li><code><strong>constructor(props)</strong></code></li>
                </ol>
                <ol type="1" start="2">
                    <li><code><strong>static getDerivedStateFromProps(nextProps, nextState)</strong></code></li>
                </ol>
                <ol type="1" start="3">
                    <li><code><strong>render()</strong></code></li>
                </ol>
                <ol type="1" start="4">
                    <li><code><strong>componentDidMount()</strong></code></li>
                </ol>
                <h3>1. <code><strong>constructor(props)</strong></code>
                    – Initializing State and Binding Methods</h3>
                <p>The <code>constructor()</code> is the first method
                    called when a class component is created. It’s primarily used for:</p>
                <ul>
                    <li><strong>Initializing state</strong>: This is where you can set the
                        initial values for the component's state.</li>
                </ul>
                <ul>
                    <li><strong>Binding event handlers</strong>: If you need to bind
                        methods to
                        the class instance (e.g., for event handling), it’s done here.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span> <span>// Call the parent constructor</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span>
      <span>count</span><span>:</span> <span>0</span><span>,</span> <span>// Initialize state</span>
    <span>}</span><span>;</span>
    <span>this</span><span>.</span>increment <span>=</span> <span>this</span><span>.</span><span>increment</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>// Bind event handler</span>
  <span>}</span>
  
  <span>increment</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> <span>count</span><span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><code>constructor()</code> is called only <strong>once</strong>
                        when
                        the component is instantiated.</li>
                </ul>
                <ul>
                    <li>You <strong>must call
                        </strong><code><strong>super(props)</strong></code> in the constructor to access
                        <code>this</code>
                        (the instance of the component).
                    </li>
                </ul>
                <hr>
                <h3>2.
                    <code><strong>static getDerivedStateFromProps(nextProps, nextState)</strong></code> – Updating State
                    Based on Props
                </h3>
                <ul>
                    <li><code><strong>getDerivedStateFromProps()</strong></code> is a
                        <strong>static method</strong> and is called <strong>before every render</strong> (including
                        mounting).
                    </li>
                </ul>
                <ul>
                    <li>It is called with the <strong>nextProps</strong> and
                        <strong>nextState</strong> as arguments and can return an object that updates the component's
                        state.
                    </li>
                </ul>
                <ul>
                    <li>This method is useful if you need to derive state from incoming
                        props
                        (e.g., when props change and should trigger an update in the component state).</li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span>
      <span>count</span><span>:</span> <span>0</span><span>,</span>
    <span>}</span><span>;</span>
  <span>}</span>
  
  <span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextState<span>.</span>count <span>&gt;</span> <span>5</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>5</span> <span>}</span><span>;</span> <span>// Limit count to a maximum of 5</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span> <span>// No changes to state</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Why use
                        </strong><code><strong>getDerivedStateFromProps</strong></code><strong>?</strong> This is often
                        used
                        when the state needs to be updated based on props, but it can also be used to reset or modify
                        the
                        state based on certain conditions.</li>
                </ul>
                <hr>
                <h3>3. <code><strong>render()</strong></code> –
                    Returning JSX to Render the Component</h3>
                <ul>
                    <li>The <code><strong>render()</strong></code> method is
                        <strong>required</strong> in every class component. It’s called during the mounting phase to
                        determine
                        what the component should display.
                    </li>
                </ul>
                <ul>
                    <li><code>render()</code> returns <strong>JSX</strong> (which gets
                        converted to HTML in the browser) or <code>null</code> if nothing should be displayed.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span> <span>// JSX returned for rendering</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Important</strong>: The
                        <code><strong>render()</strong></code>
                        method should be <strong>pure</strong>, meaning it should return the same output for the same
                        input
                        (state and props).
                    </li>
                </ul>
                <ul>
                    <li><code><strong>render()</strong></code> is the only lifecycle method
                        that is <strong>required</strong> in class components.</li>
                </ul>
                <hr>
                <h3>4.
                    <code><strong>componentDidMount()</strong></code> – Initializing Side Effects
                </h3>
                <ul>
                    <li><code><strong>componentDidMount()</strong></code> is called
                        immediately
                        <strong>after the component is inserted into the DOM</strong>.
                    </li>
                </ul>
                <ul>
                    <li>This is the perfect place to initiate any side effects, such as:<ul>
                            <li>Fetching data from an API.</li>
                        </ul>
                        <ul>
                            <li>Setting up subscriptions or event listeners.</li>
                        </ul>
                        <ul>
                            <li>Initializing third-party libraries or timers.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li>The <code><strong>componentDidMount()</strong></code> method is
                        called
                        <strong>once</strong> after the first render and not during subsequent re-renders.
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>data</span><span>:</span> <span>null</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>// Fetching data from an API after the component is mounted</span>
    <span>fetch</span><span>(</span><span>'https://api.example.com/data'</span><span>)</span>
      <span>.</span><span>then</span><span>(</span><span>response</span> <span>=&gt;</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span>
      <span>.</span><span>then</span><span>(</span><span>data</span> <span>=&gt;</span> <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> data <span>}</span><span>)</span><span>)</span>
      <span>.</span><span>catch</span><span>(</span><span>error</span> <span>=&gt;</span> console<span>.</span><span>error</span><span>(</span><span>'Error fetching data:'</span><span>,</span> error<span>)</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> data <span>}</span> <span>=</span> <span>this</span><span>.</span>state<span>;</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>{</span>data <span>?</span> <span>&lt;</span>p<span>&gt;</span>Data<span>:</span> <span>{</span>data<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span> <span>:</span> <span>&lt;</span>p<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>p<span>&gt;</span><span>}</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Why
                        </strong><code><strong>componentDidMount()</strong></code><strong>?</strong> It runs after the
                        DOM is
                        ready, making it the ideal place to trigger side effects (e.g., fetching data, interacting with
                        the
                        DOM, or initializing external libraries) that depend on the DOM being available.</li>
                </ul>
                <hr>
                <h3><strong>Mounting Phase Summary in Class
                        Components</strong></h3>
                <p>The mounting phase consists of the following
                    lifecycle methods:</p>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Method</strong></td>
                            <td><strong>Description</strong></td>
                            <td><strong>When It's Called</strong></td>
                        </tr>
                        <tr>
                            <td><code><strong>constructor(props)</strong></code></td>
                            <td>Initializes state and binds event handlers.</td>
                            <td>Called when the component is created (once).</td>
                        </tr>
                        <tr>
                            <td><code><strong>getDerivedStateFromProps()</strong></code></td>
                            <td>Allows state updates based on props. <strong>Static method</strong>.
                            </td>
                            <td>Called before every render (both mounting and updating).</td>
                        </tr>
                        <tr>
                            <td><code><strong>render()</strong></code></td>
                            <td>Returns JSX to render the component.</td>
                            <td>Called every time the component renders.</td>
                        </tr>
                        <tr>
                            <td><code><strong>componentDidMount()</strong></code></td>
                            <td>Initializes side effects, like fetching data, once the component
                                mounts.</td>
                            <td>Called once, immediately after the component is mounted (first
                                render).</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Mounting in Functional Components (Using
                    </strong><code><strong>useEffect</strong></code><strong>)</strong></h3>
                <p>In <strong>functional components</strong>, the
                    <code>useEffect</code> hook is used to handle mounting and other lifecycle events.
                </p>
                <ul>
                    <li><strong>Mounting equivalent in functional components</strong>:
                        <code>useEffect</code> runs after the component has been rendered to the screen, similar to
                        <code>componentDidMount</code> in class components.
                    </li>
                </ul>
                <ul>
                    <li><code><strong>useEffect</strong></code><strong> with an empty
                            dependency array </strong><code><strong>[]</strong></code> will run <strong>only
                            once</strong> after
                        the first render (just like <code>componentDidMount</code>).</li>
                </ul>
                <p><strong>Example using
                    </strong><code><strong>useEffect</strong></code><strong> in a functional component:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>data<span>,</span> setData<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Equivalent of componentDidMount in functional components</span>
    <span>fetch</span><span>(</span><span>'https://api.example.com/data'</span><span>)</span>
      <span>.</span><span>then</span><span>(</span><span>response</span> <span>=&gt;</span> response<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span>
      <span>.</span><span>then</span><span>(</span><span>data</span> <span>=&gt;</span> <span>setData</span><span>(</span>data<span>)</span><span>)</span>
      <span>.</span><span>catch</span><span>(</span><span>error</span> <span>=&gt;</span> console<span>.</span><span>error</span><span>(</span><span>'Error fetching data:'</span><span>,</span> error<span>)</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// Empty dependency array means it runs only once, after the first render.</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>{</span>data <span>?</span> <span>&lt;</span>p<span>&gt;</span>Data<span>:</span> <span>{</span>data<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span> <span>:</span> <span>&lt;</span>p<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>p<span>&gt;</span><span>}</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><code>useEffect</code> with an empty array (<code>[]</code>) runs
                        after
                        the <strong>initial mount</strong> of the component, allowing us to handle side effects like
                        fetching
                        data or setting up subscriptions.</li>
                </ul>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li><strong>Mounting</strong> is the process when a component is
                        created
                        and inserted into the DOM.</li>
                </ul>
                <ul>
                    <li>In <strong>class components</strong>, the mounting phase includes
                        <code>constructor()</code>, <code>getDerivedStateFromProps()</code>, <code>render()</code>, and
                        <code>componentDidMount()</code>.
                    </li>
                </ul>
                <ul>
                    <li>In <strong>functional components</strong>, mounting is handled by
                        the
                        <code>useEffect</code> hook, with the empty dependency array <code>[]</code> ensuring it runs
                        only
                        once.
                    </li>
                </ul>
                <ul>
                    <li>The mounting phase is a critical time to set up the initial state,
                        initialize side effects (like data fetching), and perform any setup that depends on the DOM.
                    </li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Updating</strong></summary>
            <div class="content">
                <h3><strong>Updating Phase in React (Detailed
                        Explanation)</strong></h3>
                <p>The <strong>updating phase</strong> in React occurs
                    when a component's <strong>state</strong> or <strong>props</strong> change after the component has
                    already been mounted. When either of these changes, React needs to re-render the component to
                    reflect
                    the updated data in the DOM. During this phase, React goes through several lifecycle methods (for
                    class
                    components) or hooks (for functional components) to handle these updates.</p>
                <p>The updating phase is important because it controls
                    how your component reacts to changes in state or props, and allows you to optimize the component's
                    performance and behavior when data changes.</p>
                <hr>
                <h3><strong>Updating in Class Components</strong></h3>
                <p>In class components, the updating phase involves
                    several lifecycle methods, each responsible for handling different aspects of state and props
                    changes:
                </p>
                <h3>1.
                    <code><strong>static getDerivedStateFromProps(nextProps, nextState)</strong></code> (Called before
                    every
                    render)
                </h3>
                <ul>
                    <li><code><strong>getDerivedStateFromProps()</strong></code> is a
                        <strong>static method</strong> and is called before <strong>every render</strong>, whether it's
                        during
                        mounting or updating.
                    </li>
                </ul>
                <ul>
                    <li>It receives two arguments:<ul>
                            <li><code>nextProps</code>: The new props that are being
                                passed to
                                the component.</li>
                        </ul>
                        <ul>
                            <li><code>nextState</code>: The new state of the component
                                after the
                                change.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li>It can return an object to update the state or <code>null</code> if
                        no
                        state change is required.</li>
                </ul>
                <ul>
                    <li><strong>Use Case</strong>: This method is generally used when you
                        need
                        to update the component's internal state based on the incoming props.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>static</span> <span>getDerivedStateFromProps</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>nextProps<span>.</span>count <span>&gt;</span> <span>5</span><span>)</span> <span>{</span>
      <span>return</span> <span>{</span> <span>count</span><span>:</span> <span>5</span> <span>}</span><span>;</span> <span>// Limit the count to 5</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span> <span>// No change to state</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Note</strong>: <code>getDerivedStateFromProps()</code> is
                        called <strong>before every render</strong>, and can be useful if you need to adjust the state
                        based
                        on props. However, it is rarely used since it can be considered redundant in many cases.</li>
                </ul>
                <hr>
                <h3>2.
                    <code><strong>shouldComponentUpdate(nextProps, nextState)</strong></code> (Optimizing Updates)
                </h3>
                <ul>
                    <li><code><strong>shouldComponentUpdate()</strong></code> is called
                        <strong>before re-rendering</strong> when either <strong>props</strong> or
                        <strong>state</strong>
                        change.
                    </li>
                </ul>
                <ul>
                    <li>It allows you to <strong>optimize performance</strong> by
                        preventing
                        unnecessary re-renders. By default, React always re-renders the component when there’s a state
                        or prop
                        change.</li>
                </ul>
                <ul>
                    <li><strong>Returns</strong>:<ul>
                            <li><code>true</code>: If you want the component to
                                re-render.</li>
                        </ul>
                        <ul>
                            <li><code>false</code>: If you want to prevent the re-render
                                (useful
                                for optimization).</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><strong>Use Case</strong>: This is used to optimize the rendering
                        process, especially in large applications where unnecessary re-renders can hurt performance.
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>shouldComponentUpdate</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>
    <span>// Only re-render if the count value has changed</span>
    <span>if</span> <span>(</span><span>this</span><span>.</span>state<span>.</span>count <span>===</span> nextState<span>.</span>count<span>)</span> <span>{</span>
      <span>return</span> <span>false</span><span>;</span> <span>// Prevent re-render if count hasn't changed</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span> <span>// Otherwise, re-render</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Important</strong>: <code>shouldComponentUpdate()</code>
                        can be
                        used to avoid unnecessary re-renders when the props or state do not change in meaningful ways.
                    </li>
                </ul>
                <hr>
                <h3>3. <code><strong>render()</strong></code>
                    (Re-rendering the Component)</h3>
                <ul>
                    <li>The <code><strong>render()</strong></code> method is called during
                        <strong>every update</strong>, including when the component receives new props or when its state
                        changes.
                    </li>
                </ul>
                <ul>
                    <li>It is responsible for returning the JSX that should be rendered to
                        the
                        DOM.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span> <span>// JSX to render</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Note</strong>: The <code>render()</code> method should be
                        <strong>pure</strong> — it should not contain side effects and should always return the same
                        output
                        given the same input (<code>state</code> and <code>props</code>).
                    </li>
                </ul>
                <hr>
                <h3>4.
                    <code><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></code> (Capturing Information
                    Before the Update)
                </h3>
                <ul>
                    <li><code><strong>getSnapshotBeforeUpdate()</strong></code> is called
                        <strong>right before</strong> React applies the changes to the DOM after the render.
                    </li>
                </ul>
                <ul>
                    <li>It is used to capture information from the DOM (e.g., scroll
                        position,
                        layout measurements) <strong>before</strong> the DOM is updated.</li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>getSnapshotBeforeUpdate</span><span>(</span><span>prevProps<span>,</span> prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prevState<span>.</span>count <span>!==</span> <span>this</span><span>.</span>state<span>.</span>count<span>)</span> <span>{</span>
      <span>return</span> window<span>.</span>scrollY<span>;</span> <span>// Capture the current scroll position</span>
    <span>}</span>
    <span>return</span> <span>null</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>componentDidUpdate</span><span>(</span><span>prevProps<span>,</span> prevState<span>,</span> snapshot</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>snapshot <span>!==</span> <span>null</span><span>)</span> <span>{</span>
      window<span>.</span><span>scrollTo</span><span>(</span><span>0</span><span>,</span> snapshot<span>)</span><span>;</span> <span>// Scroll back to the previous position</span>
    <span>}</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Why use
                        </strong><code><strong>getSnapshotBeforeUpdate</strong></code><strong>?</strong> This is useful
                        when
                        you need to measure or capture the current DOM state (like scroll position or element size)
                        <strong>before</strong> the update happens, so that you can react accordingly after the update
                        (in
                        <code>componentDidUpdate()</code>).
                    </li>
                </ul>
                <hr>
                <h3>5.
                    <code><strong>componentDidUpdate(prevProps, prevState, snapshot)</strong></code> (Handling Updates
                    After
                    the DOM Changes)
                </h3>
                <ul>
                    <li><code><strong>componentDidUpdate()</strong></code> is called
                        <strong>after the component has updated</strong> the DOM with the new state or props.
                    </li>
                </ul>
                <ul>
                    <li>This method can be used to <strong>perform side effects</strong>
                        after
                        the component re-renders, such as:<ul>
                            <li>Triggering API calls.</li>
                        </ul>
                        <ul>
                            <li>Updating the DOM manually.</li>
                        </ul>
                        <ul>
                            <li>Re-running any side effects that depend on the update.
                            </li>
                        </ul>
                    </li>
                </ul>
                <p><strong>Example:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  <span>}</span>
  
  <span>componentDidUpdate</span><span>(</span><span>prevProps<span>,</span> prevState</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>prevState<span>.</span>count <span>!==</span> <span>this</span><span>.</span>state<span>.</span>count<span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Count updated:'</span><span>,</span> <span>this</span><span>.</span>state<span>.</span>count<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Why use
                        </strong><code><strong>componentDidUpdate</strong></code><strong>?</strong> This method is
                        useful when
                        you need to handle actions after the DOM has updated, such as logging changes, interacting with
                        third-party libraries, or running additional side effects based on state or prop changes.</li>
                </ul>
                <hr>
                <h3><strong>Updating Phase Summary in Class
                        Components</strong></h3>
                <p>The updating phase consists of the following
                    lifecycle methods:</p>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Method</strong></td>
                            <td><strong>Description</strong></td>
                            <td><strong>When It's Called</strong></td>
                        </tr>
                        <tr>
                            <td>
                                <code><strong>static getDerivedStateFromProps(nextProps, nextState)</strong></code>
                            </td>
                            <td>Updates state based on changes in props. <strong>Static
                                    method</strong>.</td>
                            <td>Called before every render (both mounting and updating).</td>
                        </tr>
                        <tr>
                            <td>
                                <code><strong>shouldComponentUpdate(nextProps, nextState)</strong></code>
                            </td>
                            <td>Optimizes re-renders by determining whether the component should
                                update.</td>
                            <td>Called before the component re-renders (based on state/props change).
                            </td>
                        </tr>
                        <tr>
                            <td><code><strong>render()</strong></code></td>
                            <td>Returns the JSX to render the component.</td>
                            <td>Called every time the component re-renders.</td>
                        </tr>
                        <tr>
                            <td>
                                <code><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></code>
                            </td>
                            <td>Captures information from the DOM before it is updated.</td>
                            <td>Called right before React applies changes to the DOM.</td>
                        </tr>
                        <tr>
                            <td>
                                <code><strong>componentDidUpdate(prevProps, prevState, snapshot)</strong></code>
                            </td>
                            <td>Executes side effects after the DOM has updated.</td>
                            <td>Called after the update has been applied to the DOM.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Updating in Functional Components (Using
                    </strong><code><strong>useEffect</strong></code><strong>)</strong></h3>
                <p>In <strong>functional components</strong>, the
                    <code>useEffect</code> hook is used to handle updates. <code>useEffect</code> runs after every
                    render,
                    and can be configured to run only when certain props or state change.
                </p>
                <h3><code><strong>useEffect</strong></code><strong>
                        Hook for Updating:</strong></h3>
                <ul>
                    <li>If the <strong>dependency array</strong> is empty
                        (<code>[]</code>), it
                        acts like <code>componentDidMount</code> (runs once after the first render).</li>
                </ul>
                <ul>
                    <li>If the <strong>dependency array</strong> contains specific values
                        (e.g., <code>[count]</code>), it runs after those specific values change (like
                        <code>componentDidUpdate</code>).
                    </li>
                </ul>
                <p><strong>Example using
                    </strong><code><strong>useEffect</strong></code><strong> in functional components:</strong></p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>// This effect runs every time `count` changes (like componentDidUpdate)</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Count updated:'</span><span>,</span> count<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>count<span>]</span><span>)</span><span>;</span> <span>// Dependency array: Effect runs when `count` changes</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li><strong>Why
                        </strong><code><strong>useEffect</strong></code><strong>
                            for Updates?</strong> <code>useEffect</code> can be used to handle side effects after state
                        or prop
                        changes, like data fetching, interacting with APIs, or updating the DOM.</li>
                </ul>
                <hr>
                <h3><strong>Key Takeaways</strong></h3>
                <ul>
                    <li>The <strong>updating phase</strong> occurs when a component</li>
                </ul>
                <p>'s state or props change.</p>
                <ul>
                    <li>In <strong>class components</strong>, this phase involves methods
                        like
                        <code>getDerivedStateFromProps()</code>, <code>shouldComponentUpdate()</code>,
                        <code>render()</code>,
                        <code>getSnapshotBeforeUpdate()</code>, and <code>componentDidUpdate()</code>.
                    </li>
                </ul>
                <ul>
                    <li>In <strong>functional components</strong>, the
                        <code>useEffect</code>
                        hook is used to handle updates, with specific dependencies to determine when the effect should
                        run.
                    </li>
                </ul>
                <ul>
                    <li>Proper use of these methods/hooks ensures optimal performance,
                        correct
                        side effect handling, and proper updates to the DOM when state or props change.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Unmounting</strong></summary>
            <div class="content">
                <h3><strong>Unmounting Phase in React (Detailed
                        Explanation)</strong></h3>
                <p>The <strong>unmounting phase</strong> in React
                    refers to the process when a component is removed from the <strong>DOM</strong>. This occurs when a
                    component is no longer needed or is replaced by another component in the component tree. During this
                    phase, React performs necessary clean-up tasks to ensure that the component does not leave any side
                    effects, memory leaks, or unresolved operations.</p>
                <p>The unmounting phase is an important part of
                    managing the lifecycle of components, especially when components involve <strong>event
                        listeners</strong>, <strong>timers</strong>, or <strong>network requests</strong> that should be
                    cleaned up when the component is no longer in use.</p>
                <hr>
                <h3><strong>Unmounting in Class Components</strong>
                </h3>
                <p>In class components, the unmounting phase involves a
                    single lifecycle method:</p>
                <h3>
                    <code><strong>componentWillUnmount()</strong></code>
                </h3>
                <ul>
                    <li><code><strong>componentWillUnmount()</strong></code> is the
                        <strong>only lifecycle method</strong> invoked during the unmounting phase.
                    </li>
                </ul>
                <ul>
                    <li>It is called <strong>immediately before a component is removed from
                            the
                            DOM</strong>.</li>
                </ul>
                <ul>
                    <li>This method is used to clean up resources, stop network requests,
                        remove event listeners, cancel timers, or do any other necessary clean-up to avoid memory leaks.
                    </li>
                </ul>
                <p><strong>Key Use Cases for
                    </strong><code><strong>componentWillUnmount()</strong></code>:</p>
                <ul>
                    <li>Removing event listeners (e.g., keyboard or mouse events).</li>
                </ul>
                <ul>
                    <li>Invalidating network requests or cancelling subscriptions.</li>
                </ul>
                <ul>
                    <li>Clearing timers (e.g., <code>setTimeout</code>,
                        <code>setInterval</code>).
                    </li>
                </ul>
                <ul>
                    <li>Clearing intervals or timeouts to prevent unexpected behavior after
                        the
                        component is gone.</li>
                </ul>
                <h3><strong>Example of
                    </strong><code><strong>componentWillUnmount()</strong></code></h3>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
    <span>this</span><span>.</span>handleResize <span>=</span> <span>this</span><span>.</span><span>handleResize</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    <span>// Set up event listener when component mounts</span>
    window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>this</span><span>.</span>handleResize<span>)</span><span>;</span>
  <span>}</span>
  
  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span>
    <span>// Clean up event listener when component is unmounted</span>
    window<span>.</span><span>removeEventListener</span><span>(</span><span>'resize'</span><span>,</span> <span>this</span><span>.</span>handleResize<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>'Component is being unmounted, cleanup done'</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>handleResize</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Window resized'</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li>In this example,
                        <code><strong>componentWillUnmount()</strong></code>
                        is used to remove the event listener for <code>resize</code> to prevent memory leaks or unwanted
                        behavior when the component is unmounted.
                    </li>
                </ul>
                <ul>
                    <li><strong>Important</strong>: You should always clean up side effects
                        or
                        subscriptions (like network requests, timers, or event listeners) inside
                        <code>componentWillUnmount()</code>.
                    </li>
                </ul>
                <hr>
                <h3><strong>Unmounting in Functional Components (Using
                    </strong><code><strong>useEffect</strong></code><strong>)</strong></h3>
                <p>In <strong>functional components</strong>, React
                    manages side effects using the <code>useEffect</code> hook. The <strong>cleanup</strong> for the
                    unmounting phase is handled inside the <strong>return function</strong> of the
                    <code>useEffect</code>
                    hook.
                </p>
                <h3><strong>Cleaning Up with
                    </strong><code><strong>useEffect</strong></code></h3>
                <ul>
                    <li>In functional components, <code>useEffect</code> provides an easy
                        way
                        to handle <strong>side effects</strong> (like network requests, timers, subscriptions, etc.),
                        and it
                        also allows you to clean up those side effects when the component is unmounted or when certain
                        dependencies change.</li>
                </ul>
                <ul>
                    <li><strong>Cleanup</strong> is done in the <strong>return
                            function</strong> of <code>useEffect</code>.</li>
                </ul>
                <h3><strong>Syntax of Cleanup in
                    </strong><code><strong>useEffect</strong></code><strong>:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// Setup side effect (e.g., network request, event listener)</span>
  
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Cleanup function</span>
    <span>// This is called during unmounting or before the next effect runs</span>
    <span>// Remove event listeners, clear timers, cancel network requests, etc.</span>
  <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>  <span>// Empty dependency array ensures the effect runs only once (like componentDidMount)</span>
  </code></pre>
                <ul>
                    <li>The <strong>cleanup function</strong> inside <code>useEffect</code>
                        will be called when:<ol type="1" start="1">
                            <li>The component is unmounted.</li>
                        </ol>
                        <ol type="1" start="2">
                            <li>When the dependencies of the <code>useEffect</code> change (if there are any
                                dependencies).</li>
                        </ol>
                    </li>
                </ul>
                <h3><strong>Example of Cleanup in Functional
                        Component</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Set up event listener for window resize</span>
    <span>const</span> <span>handleResize</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'Window resized'</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
    window<span>.</span><span>addEventListener</span><span>(</span><span>'resize'</span><span>,</span> handleResize<span>)</span><span>;</span>
  
    <span>// Cleanup: Remove the event listener when the component unmounts</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      window<span>.</span><span>removeEventListener</span><span>(</span><span>'resize'</span><span>,</span> handleResize<span>)</span><span>;</span>
      console<span>.</span><span>log</span><span>(</span><span>'Component is unmounted, cleanup done'</span><span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>  <span>// Empty dependency array ensures this effect runs only once</span>
  
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                <ul>
                    <li>In this example, <code>useEffect</code> is used to add an event
                        listener for window resize. The <strong>cleanup function</strong> inside <code>useEffect</code>
                        is
                        used to remove the event listener when the component is unmounted.</li>
                </ul>
                <ul>
                    <li><strong>Important</strong>: The cleanup function is also called
                        when
                        the component <strong>re-renders</strong> (if there are changes in the dependencies). In this
                        case,
                        because the dependency array is empty (<code>[]</code>), it only runs on mount and unmount.</li>
                </ul>
                <hr>
                <h3><strong>Key Points to Remember About
                        Unmounting</strong></h3>
                <h3><strong>For Class Components</strong>:</h3>
                <ul>
                    <li>The <code><strong>componentWillUnmount()</strong></code> method is
                        called immediately before a component is removed from the DOM.</li>
                </ul>
                <ul>
                    <li>It is the best place to clean up any side effects (e.g., event
                        listeners, timers, or subscriptions) to avoid <strong>memory leaks</strong>.</li>
                </ul>
                <h3><strong>For Functional Components</strong>:</h3>
                <ul>
                    <li>In functional components, cleanup is done within the
                        <code><strong>useEffect</strong></code><strong> hook</strong>.
                    </li>
                </ul>
                <ul>
                    <li>The cleanup function is returned from the <code>useEffect</code>
                        hook
                        and is automatically called when the component unmounts, or before the next effect runs if the
                        dependencies change.</li>
                </ul>
                <h3><strong>Examples of Things to Clean Up</strong>:
                </h3>
                <ol type="1" start="1">
                    <li><strong>Event Listeners</strong>: Always remove event listeners when the component is unmounted
                        to
                        prevent memory leaks or unnecessary event handling.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Timers/Intervals</strong>: Clear any timers or intervals (<code>setTimeout</code>,
                        <code>setInterval</code>) that were set up in the component to prevent them from continuing to
                        execute
                        after the component is unmounted.
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Network Requests</strong>: Cancel any ongoing network requests to prevent the component
                        from
                        attempting to update state after it has been unmounted, avoiding potential errors.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Subscriptions</strong>: Unsubscribe from external services, WebSocket connections, or
                        data
                        streams to avoid memory leaks or unnecessary background tasks after the component is no longer
                        in the
                        DOM.</li>
                </ol>
                <hr>
                <h3><strong>Unmounting Phase Summary</strong></h3>
                <p>The unmounting phase involves cleaning up side
                    effects and resources when the component is removed from the DOM.</p>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Method / Hook</strong></td>
                            <td><strong>Description</strong></td>
                            <td><strong>When It's Called</strong></td>
                        </tr>
                        <tr>
                            <td><code><strong>componentWillUnmount()</strong></code></td>
                            <td>Cleans up resources before the component is removed from the DOM.
                            </td>
                            <td>Called right before the component is unmounted (class components).
                            </td>
                        </tr>
                        <tr>
                            <td><code><strong>useEffect</strong></code><strong> Cleanup
                                    Function</strong>
                            </td>
                            <td>Handles side effects and cleans up resources (e.g., timers, event
                                listeners).
                            </td>
                            <td>Called when the component unmounts (or before the next effect in
                                functional
                                components).</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Best Practices for Unmounting
                        Phase</strong>:</h3>
                <ul>
                    <li>Always clean up <strong>event listeners</strong>, <strong>network
                            requests</strong>, <strong>timers</strong>, and other side effects to prevent memory leaks.
                    </li>
                </ul>
                <ul>
                    <li>In <strong>class components</strong>, use
                        <code><strong>componentWillUnmount()</strong></code> for cleanup.
                    </li>
                </ul>
                <ul>
                    <li>In <strong>functional components</strong>, use the cleanup function
                        in
                        the <code><strong>useEffect</strong></code><strong> hook</strong>.</li>
                </ul>
                <ul>
                    <li>Cleaning up properly ensures that the component does not leave
                        lingering processes or handlers after it is unmounted, leading to better performance and fewer
                        bugs.
                    </li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Hooks and Rule for Hooks</strong></summary>
            <div class="content">
                <h3><strong>What are Hooks in React?</strong></h3>
                <p><strong>Hooks</strong> are a way to add state and
                    side effects to <strong>functional components</strong> in React. Before React 16.8, only
                    <strong>class
                        components</strong> could have state, lifecycle methods, and other features. With hooks, you can
                    use
                    these features in <strong>functional components</strong>, making it easier to work with components
                    and
                    manage their behavior without having to convert them to class components.
                </p>
                <p>Hooks allow you to:</p>
                <ol type="1" start="1">
                    <li>Use <strong>state</strong> (<code>useState</code>).</li>
                </ol>
                <ol type="1" start="2">
                    <li>Perform <strong>side effects</strong> (e.g., fetching data, subscriptions)
                        (<code>useEffect</code>).
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li>Share <strong>logic</strong> between components (<code>useContext</code>,
                        <code>useReducer</code>,
                        custom hooks, etc.).
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li>Access <strong>context</strong> (<code>useContext</code>).</li>
                </ol>
                <h3><strong>Common React Hooks</strong></h3>
                <p>Here are some of the most commonly used hooks in
                    React:</p>
                <h3>1. <code><strong>useState</strong></code><strong>
                        Hook</strong> (Managing state in functional components)</h3>
                <p>The <code>useState</code> hook is used to add state
                    to functional components.</p>
                <ul>
                    <li><strong>Syntax:</strong>
                        <pre tabindex="0"><code class="language-java"><span>const</span> <span>[</span>state<span>,</span> setState<span>]</span> <span>=</span> <span>useState</span><span>(</span>initialState<span>)</span><span>;</span>
  </code></pre>
                        <ul>
                            <li><code>state</code> is the current state value.</li>
                        </ul>
                        <ul>
                            <li><code>setState</code> is the function used to update the
                                state.
                            </li>
                        </ul>
                        <ul>
                            <li><code>initialState</code> is the value you provide to
                                initialize
                                the state (can be any type: string, number, object, array, etc.).</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><strong>Example:</strong>
                        <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                    </li>
                </ul>
                <h3>2. <code><strong>useEffect</strong></code><strong>
                        Hook</strong> (Handling side effects)</h3>
                <p>The <code>useEffect</code> hook allows you to
                    perform side effects in your functional components (e.g., data fetching, event listeners, timers).
                </p>
                <ul>
                    <li><strong>Syntax:</strong>
                        <pre tabindex="0"><code class="language-java"><span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
  <span>// Side effect code here</span>
  <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Cleanup code (optional)</span>
  <span>}</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>dependencies<span>]</span><span>)</span><span>;</span>
  </code></pre>
                        <ul>
                            <li>The function passed to <code>useEffect</code> will be
                                executed
                                after the component renders.</li>
                        </ul>
                        <ul>
                            <li>You can optionally return a cleanup function to remove
                                any side
                                effects when the component unmounts or when dependencies change.</li>
                        </ul>
                        <ul>
                            <li>The <strong>dependencies array</strong> specifies when
                                the effect
                                should run. If it's empty (<code>[]</code>), the effect runs only once, similar to
                                <code>componentDidMount</code>.
                            </li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><strong>Example:</strong>
                        <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Timer</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>seconds<span>,</span> setSeconds<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> timer <span>=</span> <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setSeconds</span><span>(</span><span>(</span><span>prev</span><span>)</span> <span>=&gt;</span> prev <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
  
    <span>// Cleanup function to stop the timer when component unmounts</span>
    <span>return</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>clearInterval</span><span>(</span>timer<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>  <span>// Empty dependency array means this effect runs only once.</span>
  
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Time<span>:</span> <span>{</span>seconds<span>}</span>s<span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                    </li>
                </ul>
                <h3>3. <code><strong>useContext</strong></code><strong>
                        Hook</strong> (Context API in functional components)</h3>
                <p>The <code>useContext</code> hook allows you to
                    access the value of a React context directly within functional components.</p>
                <ul>
                    <li><strong>Syntax:</strong>
                        <pre tabindex="0"><code class="language-java"><span>const</span> value <span>=</span> <span>useContext</span><span>(</span>MyContext<span>)</span><span>;</span>
  </code></pre>
                    </li>
                </ul>
                <ul>
                    <li><strong>Example:</strong>
                        <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> createContext<span>,</span> useContext <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>const</span> ThemeContext <span>=</span> <span>createContext</span><span>(</span><span>'light'</span><span>)</span><span>;</span>  <span>// Default value 'light'</span>
  
  <span>function</span> <span>ThemedComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> theme <span>=</span> <span>useContext</span><span>(</span>ThemeContext<span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>The current theme is <span>{</span>theme<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>ThemeContext<span>.</span>Provider value<span>=</span><span>"dark"</span><span>&gt;</span>
      <span>&lt;</span>ThemedComponent <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>ThemeContext<span>.</span>Provider<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                    </li>
                </ul>
                <h3>4. <code><strong>useReducer</strong></code><strong>
                        Hook</strong> (Managing complex state)</h3>
                <p><code>useReducer</code> is an alternative to
                    <code>useState</code>, often preferred for handling more complex state logic (e.g., multiple
                    sub-values
                    or state transitions).
                </p>
                <ul>
                    <li><strong>Syntax:</strong>
                        <pre tabindex="0"><code class="language-java"><span>const</span> <span>[</span>state<span>,</span> dispatch<span>]</span> <span>=</span> <span>useReducer</span><span>(</span>reducer<span>,</span> initialState<span>)</span><span>;</span>
  </code></pre>
                        <ul>
                            <li><code>state</code> is the current state.</li>
                        </ul>
                        <ul>
                            <li><code>dispatch</code> is the function used to dispatch
                                actions to
                                update the state.</li>
                        </ul>
                        <ul>
                            <li><code>reducer</code> is a function that specifies how the
                                state
                                should change based on the dispatched actions.</li>
                        </ul>
                        <ul>
                            <li><code>initialState</code> is the initial value of the
                                state.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li><strong>Example:</strong>
                        <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useReducer <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>const</span> initialState <span>=</span> <span>{</span> <span>count</span><span>:</span> <span>0</span> <span>}</span><span>;</span>
  
  <span>function</span> <span>reducer</span><span>(</span><span>state<span>,</span> action</span><span>)</span> <span>{</span>
  <span>switch</span> <span>(</span>action<span>.</span>type<span>)</span> <span>{</span>
    <span>case</span> <span>'increment'</span><span>:</span>
      <span>return</span> <span>{</span> <span>count</span><span>:</span> state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>;</span>
    <span>case</span> <span>'decrement'</span><span>:</span>
      <span>return</span> <span>{</span> <span>count</span><span>:</span> state<span>.</span>count <span>-</span> <span>1</span> <span>}</span><span>;</span>
    <span>default</span><span>:</span>
      <span>return</span> state<span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>function</span> <span>Counter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>state<span>,</span> dispatch<span>]</span> <span>=</span> <span>useReducer</span><span>(</span>reducer<span>,</span> initialState<span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>dispatch</span><span>(</span><span>{</span> <span>type</span><span>:</span> <span>'increment'</span> <span>}</span><span>)</span><span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>dispatch</span><span>(</span><span>{</span> <span>type</span><span>:</span> <span>'decrement'</span> <span>}</span><span>)</span><span>}</span><span>&gt;</span>Decrement<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                    </li>
                </ul>
                <hr>
                <h3><strong>Rules of Hooks</strong></h3>
                <p>To ensure that hooks work correctly, React has a set
                    of <strong>rules</strong> that must be followed when using hooks in functional components. These
                    rules
                    are crucial for ensuring the correct behavior and lifecycle of hooks.</p>
                <h3>1. <strong>Only Call Hooks at the Top
                        Level</strong></h3>
                <ul>
                    <li>Hooks must be called at the <strong>top level</strong> of the
                        component
                        or hook. They should <strong>not be called conditionally</strong> or inside loops, nested
                        functions,
                        or early returns.</li>
                </ul>
                <ul>
                    <li>This is important because hooks rely on their <strong>execution
                            order</strong> in the component. React needs to maintain the correct order to manage state,
                        effects,
                        and other hook behaviors.<ul>
                            <li><strong>Correct:</strong>
                                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Example</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>  <span>// Top level hook call</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Some effect logic</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span>div<span>&gt;</span><span>{</span>count<span>}</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                            </li>
                        </ul>
                        <ul>
                            <li><strong>Incorrect:</strong>
                                <pre tabindex="0"><code class="language-java"><span>function</span> <span>Example</span><span>(</span><span><span>{</span> isVisible <span>}</span></span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>isVisible<span>)</span> <span>{</span>
    <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>  <span>// Hook inside condition (wrong)</span>
  <span>}</span>
  <span>return</span> <span>&lt;</span>div<span>&gt;</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                            </li>
                        </ul>
                    </li>
                </ul>
                <h3>2. <strong>Only Call Hooks from React
                        Functions</strong></h3>
                <ul>
                    <li>Hooks should only be called from <strong>React function
                            components</strong> or <strong>custom hooks</strong>.</li>
                </ul>
                <ul>
                    <li>They should <strong>not</strong> be called from regular JavaScript
                        functions, class components, or any non-React code.<ul>
                            <li><strong>Correct:</strong>
                                <pre tabindex="0"><code class="language-java"><span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>  <span>// Valid use of hook</span>
  <span>return</span> <span>&lt;</span>div<span>&gt;</span><span>{</span>count<span>}</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  </code></pre>
                            </li>
                        </ul>
                        <ul>
                            <li><strong>Incorrect:</strong>
                                <pre tabindex="0"><code class="language-java"><span>function</span> <span>myFunction</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>  <span>// Invalid use of hook in regular function</span>
  <span>}</span>
  </code></pre>
                            </li>
                        </ul>
                    </li>
                </ul>
                <h3>3. <strong>Custom Hooks</strong></h3>
                <ul>
                    <li>Custom hooks are just regular JavaScript functions that use hooks
                        inside them, and they <strong>must</strong> follow the same rules as regular hooks.<ul>
                            <li><strong>Example of Custom Hook:</strong>
                                <pre tabindex="0"><code class="language-java"><span>function</span> <span>useCounter</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>function</span> <span>increment</span><span>(</span><span>)</span> <span>{</span>
    <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>return</span> <span>[</span>count<span>,</span> increment<span>]</span><span>;</span>
  <span>}</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> increment<span>]</span> <span>=</span> <span>useCounter</span><span>(</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>increment<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                            </li>
                        </ul>
                    </li>
                </ul>
                <hr>
                <h3><strong>Summary of Rules for Hooks</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Call hooks only at the top level</strong> (don't call them inside loops, conditions, or
                        nested functions).</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Call hooks only from React function components</strong> or <strong>custom
                            hooks</strong>.
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Custom hooks</strong> must follow the same rules as regular hooks and must be called at
                        the
                        top level of the function.</li>
                </ol>
                <hr>
                <h3><strong>Why Hooks Are Important</strong></h3>
                <ul>
                    <li><strong>Simplicity</strong>: Hooks provide a simpler and more
                        concise
                        way to manage state, side effects, and other features in functional components.</li>
                </ul>
                <ul>
                    <li><strong>Code Reusability</strong>: Custom hooks allow you to
                        extract
                        logic and reuse it across different components, promoting cleaner and more modular code.</li>
                </ul>
                <ul>
                    <li><strong>Avoiding Class Components</strong>: With hooks, you can
                        achieve
                        functionality that was previously only possible with class components, without needing to use
                        classes,
                        which can be more verbose and harder to manage.</li>
                </ul>
                <ul>
                    <li><strong>Consistency</strong>: Hooks enable more consistent ways of
                        managing side effects, context, and state between different components in your application.</li>
                </ul>
            </div>
        </details>
        <details>
            <summary><strong>Conditional Rendering</strong></summary>
            <div class="content">
                <h3><strong>Conditional Rendering in React</strong>
                </h3>
                <p>Conditional rendering in React refers to the ability
                    to render different UI elements based on certain conditions. It allows you to dynamically change
                    what
                    gets rendered on the screen depending on some application state, props, or other criteria.</p>
                <p>In React, <strong>conditional rendering</strong>
                    works similarly to <strong>conditional statements</strong> in JavaScript (like <code>if</code>,
                    <code>else</code>, <code>switch</code>, and ternary operators). Depending on the condition, React
                    can
                    decide what to render. If the condition is true, a component or element is rendered, and if it is
                    false,
                    a different component or element (or nothing at all) is rendered.
                </p>
                <h3><strong>Ways to Achieve Conditional Rendering in
                        React</strong></h3>
                <p>Here are the most common methods for conditional
                    rendering in React:</p>
                <h3>1. <strong>Using
                    </strong><code><strong>if</strong></code><strong> /
                    </strong><code><strong>else</strong></code><strong>
                        Statements</strong></h3>
                <p>This method involves using JavaScript’s
                    <code>if</code> / <code>else</code> statement to conditionally render JSX.
                </p>
                <h3>Example:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Greeting</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>isLoggedIn<span>,</span> setIsLoggedIn<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  
  <span>if</span> <span>(</span>isLoggedIn<span>)</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Welcome back<span>,</span> User<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Please log <span>in</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Greeting<span>;</span>
  </code></pre>
                <ul>
                    <li>In this example, the component checks the <code>isLoggedIn</code>
                        state
                        and renders either the "Welcome back, User!" message or the "Please log in" message based on its
                        value.</li>
                </ul>
                <h3>2. <strong>Using Ternary Operator
                        (</strong><code><strong>condition ? true : false</strong></code><strong>)</strong></h3>
                <p>The ternary operator is a compact way to write
                    conditional statements. It can be useful when you need to conditionally render two elements based on
                    a
                    condition.</p>
                <h3>Example:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Greeting</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>isLoggedIn<span>,</span> setIsLoggedIn<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>h1<span>&gt;</span>
      <span>{</span>isLoggedIn <span>?</span> <span>'Welcome back, User!'</span> <span>:</span> <span>'Please log in'</span><span>}</span>
    <span>&lt;</span><span>/</span>h1<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Greeting<span>;</span>
  </code></pre>
                <ul>
                    <li>The ternary operator is more concise than the
                        <code>if</code>/<code>else</code> statement and is often used in JSX expressions where only two
                        possible outcomes are needed.
                    </li>
                </ul>
                <h3>3. <strong>Using
                    </strong><code><strong>&amp;&amp;</strong></code><strong> (Logical AND) Operator</strong></h3>
                <p>If you only want to render something when a
                    condition is <strong>true</strong>, you can use the logical <code>&amp;&amp;</code> operator. If the
                    condition is true, the expression after <code>&amp;&amp;</code> will be rendered; if it is false,
                    React
                    will render nothing.</p>
                <h3>Example:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Greeting</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>isLoggedIn<span>,</span> setIsLoggedIn<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> User<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>{</span>isLoggedIn <span>&amp;&amp;</span> <span>&lt;</span>h2<span>&gt;</span>Welcome back<span>!</span><span>&lt;</span><span>/</span>h2<span>&gt;</span><span>}</span> <span>{</span><span>/* Renders only if isLoggedIn is true */</span><span>}</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Greeting<span>;</span>
  </code></pre>
                <ul>
                    <li>In this case, if <code>isLoggedIn</code> is <code>true</code>,
                        <code>&lt;h2&gt;Welcome back!&lt;/h2&gt;</code> will be rendered. If <code>isLoggedIn</code> is
                        <code>false</code>, nothing will be rendered (because <code>&amp;&amp;</code> short-circuits).
                    </li>
                </ul>
                <h3>4. <strong>Switch Statement</strong></h3>
                <p>You can also use the <code>switch</code> statement
                    for more complex conditional rendering with multiple possible outcomes. This is useful when you have
                    multiple conditions to check.</p>
                <h3>Example:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>StatusMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>status<span>,</span> setStatus<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>'loading'</span><span>)</span><span>;</span>
  
  <span>let</span> message<span>;</span>
  
  <span>switch</span> <span>(</span>status<span>)</span> <span>{</span>
    <span>case</span> <span>'loading'</span><span>:</span>
      message <span>=</span> <span>'Loading...'</span><span>;</span>
      <span>break</span><span>;</span>
    <span>case</span> <span>'success'</span><span>:</span>
      message <span>=</span> <span>'Data fetched successfully!'</span><span>;</span>
      <span>break</span><span>;</span>
    <span>case</span> <span>'error'</span><span>:</span>
      message <span>=</span> <span>'There was an error.'</span><span>;</span>
      <span>break</span><span>;</span>
    <span>default</span><span>:</span>
      message <span>=</span> <span>'Unknown status'</span><span>;</span>
  <span>}</span>
  
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span><span>{</span>message<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> StatusMessage<span>;</span>
  </code></pre>
                <ul>
                    <li>The <code>switch</code> statement is helpful when you have more
                        than
                        two possible outcomes, as it makes your code more readable and maintainable.</li>
                </ul>
                <h3>5. <strong>Short-Circuit Evaluation</strong></h3>
                <p>React also allows you to use <strong>short-circuit
                        evaluation</strong> to conditionally render elements. This is similar to the
                    <code>&amp;&amp;</code>
                    operator but can be used in more flexible ways.
                </p>
                <h3>Example (Rendering <code>null</code>):</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>Greeting</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>isLoggedIn<span>,</span> setIsLoggedIn<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> User<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>{</span>isLoggedIn <span>||</span> <span>&lt;</span>h2<span>&gt;</span>Please log <span>in</span><span>!</span><span>&lt;</span><span>/</span>h2<span>&gt;</span><span>}</span>  <span>{</span><span>/* Renders if isLoggedIn is false */</span><span>}</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Greeting<span>;</span>
  </code></pre>
                <ul>
                    <li>In this example, <code>isLoggedIn</code> is <code>false</code>, so
                        the
                        second <code>&lt;h2&gt;Please log in!&lt;/h2&gt;</code> will be rendered.</li>
                </ul>
                <h3>6. <strong>Return
                    </strong><code><strong>null</strong></code><strong> for No Rendering</strong></h3>
                <p>Sometimes you might want to render nothing at all.
                    You can return <code>null</code> explicitly when you don’t want to display anything.</p>
                <h3>Example:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ShowMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>shouldShow<span>,</span> setShouldShow<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>false</span><span>)</span><span>;</span>
  
  <span>if</span> <span>(</span><span>!</span>shouldShow<span>)</span> <span>{</span>
    <span>return</span> <span>null</span><span>;</span>  <span>// Nothing will be rendered</span>
  <span>}</span>
  
  <span>return</span> <span>&lt;</span>h1<span>&gt;</span>Welcome to the page<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ShowMessage<span>;</span>
  </code></pre>
                <ul>
                    <li>Here, if <code>shouldShow</code> is <code>false</code>, the
                        component
                        will return <code>null</code>, which means React will not render anything for that component.
                    </li>
                </ul>
                <h3><strong>Examples of Conditional Rendering with
                        Buttons and Events</strong></h3>
                <p>You can also use conditional rendering in response
                    to user interactions such as clicking buttons. For example:</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ToggleMessage</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>isVisible<span>,</span> setIsVisible<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>true</span><span>)</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>{</span>isVisible <span>&amp;&amp;</span> <span>&lt;</span>h1<span>&gt;</span>This message is toggled<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span><span>}</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>)</span> <span>=&gt;</span> <span>setIsVisible</span><span>(</span><span>!</span>isVisible<span>)</span><span>}</span><span>&gt;</span>
        Toggle Message
      <span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ToggleMessage<span>;</span>
  </code></pre>
                <ul>
                    <li>In this example, clicking the <strong>Toggle Message</strong>
                        button
                        will toggle the visibility of the message by updating the <code>isVisible</code> state, causing
                        a
                        re-render with the condition.</li>
                </ul>
                <h3><strong>Summary of Conditional Rendering
                        Techniques</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Technique</strong></td>
                            <td><strong>How It Works</strong></td>
                        </tr>
                        <tr>
                            <td><code><strong>if</strong></code><strong> /
                                </strong><code><strong>else</strong></code><strong> Statements</strong></td>
                            <td>Use for longer, more complex conditional rendering. Great for
                                multiple
                                outcomes.</td>
                        </tr>
                        <tr>
                            <td><strong>Ternary Operator</strong></td>
                            <td>A concise way to render based on a condition. Suitable for 2 possible
                                outcomes.</td>
                        </tr>
                        <tr>
                            <td><code><strong>&amp;&amp;</strong></code><strong> (Logical
                                    AND)</strong></td>
                            <td>Renders an element only if the condition is true. Renders nothing if
                                false.
                            </td>
                        </tr>
                        <tr>
                            <td><strong>Switch Statement</strong></td>
                            <td>Use when there are multiple possible outcomes. Good for handling
                                several
                                conditions.</td>
                        </tr>
                        <tr>
                            <td><strong>Short-Circuit Evaluation</strong></td>
                            <td>Use `</td>
                        </tr>
                        <tr>
                            <td><strong>Return </strong><code><strong>null</strong></code></td>
                            <td>Return <code>null</code> if nothing should be rendered.</td>
                        </tr>
                    </tbody>
                </table>
                <h3><strong>Best Practices for Conditional
                        Rendering</strong></h3>
                <ul>
                    <li><strong>Avoid excessive complexity</strong>: Try to keep
                        conditional
                        logic simple in your JSX for better readability.</li>
                </ul>
                <ul>
                    <li><strong>Use conditional logic outside of JSX</strong>: If the logic
                        is
                        too complicated, consider calculating the result before the return statement or using helper
                        functions.</li>
                </ul>
                <ul>
                    <li><strong>Be mindful of performance</strong>: Avoid unnecessary
                        re-renders by properly managing component states that control conditional rendering.</li>
                </ul>
                <p>Conditional rendering in React gives you the
                    flexibility to render dynamic content based on the application state, props, or user interactions,
                    enabling the creation of highly interactive UIs.</p>
            </div>
        </details>
        <details>
            <summary><strong>Lists and Keys</strong></summary>
            <div class="content">
                <h3><strong>Lists and Keys in React</strong></h3>
                <p>In React, lists and keys are essential concepts for
                    efficiently rendering and updating collections of items, such as arrays of components or data. Let's
                    dive into what lists and keys are and how they work in React.</p>
                <hr>
                <h3><strong>1. Rendering Lists in React</strong></h3>
                <p>React allows you to render a list of items
                    dynamically by iterating over an array or object and rendering a component for each element. You can
                    use
                    JavaScript's array methods like <code>map()</code> to create an array of React elements that can be
                    rendered in the JSX.</p>
                <h3><strong>Rendering Lists with
                    </strong><code><strong>map()</strong></code></h3>
                <p>In React, you typically use the <code>map()</code>
                    method to transform an array into a list of React elements. This is similar to how you'd use
                    <code>map()</code> in regular JavaScript, but you return JSX from the callback function instead of
                    regular data.
                </p>
                <h3><strong>Example: Rendering a List of Items</strong>
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ItemList</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> items <span>=</span> <span>[</span><span>'Apple'</span><span>,</span> <span>'Banana'</span><span>,</span> <span>'Orange'</span><span>,</span> <span>'Grapes'</span><span>]</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>ul<span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>li key<span>=</span><span>{</span>index<span>}</span><span>&gt;</span><span>{</span>item<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>  <span>// Each item is rendered as a list item</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span>ul<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ItemList<span>;</span>
  </code></pre>
                <p>In the example above, we use <code>map()</code> to
                    loop over the <code>items</code> array, and for each item, we create an <code>&lt;li&gt;</code>
                    element
                    with the value of the item. Each list item is rendered inside an unordered list
                    (<code>&lt;ul&gt;</code>).</p>
                <h3><strong>2. Why Keys are Important in React
                        Lists</strong></h3>
                <p>When rendering lists of elements, <strong>React
                        needs a way to uniquely identify each element</strong> to keep track of updates and changes
                    efficiently. This is where <strong>keys</strong> come into play. Keys help React identify which
                    items in
                    the list have changed, been added, or been removed.</p>
                <ul>
                    <li>Without keys, React would have to re-render all items in the list,
                        potentially affecting performance.</li>
                </ul>
                <ul>
                    <li>With keys, React can optimize the update process by comparing the
                        keys
                        and determining exactly which items need to be re-rendered.</li>
                </ul>
                <h3><strong>Key Property</strong></h3>
                <ul>
                    <li><code><strong>key</strong></code> is a special attribute in React
                        that
                        you need to assign to each element when rendering lists. It must be unique among the siblings in
                        the
                        list (not globally unique).</li>
                </ul>
                <ul>
                    <li><strong>Keys should not be used for styling or
                            presentation</strong>.
                        They are purely for React's internal performance optimizations.</li>
                </ul>
                <h3><strong>How Keys Work</strong></h3>
                <ul>
                    <li>When you update a list, React compares the keys of the current and
                        new
                        elements to figure out which items need to be updated or moved.</li>
                </ul>
                <ul>
                    <li>If the <code>key</code> for an item changes (e.g., if the list is
                        reordered or the item is replaced), React will remove the old item and add the new one instead
                        of
                        simply reusing the previous one.</li>
                </ul>
                <h3><strong>Example with Keys in Lists</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ShoppingList</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> items <span>=</span> <span>[</span>
    <span>{</span> <span>id</span><span>:</span> <span>1</span><span>,</span> <span>name</span><span>:</span> <span>'Apple'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>2</span><span>,</span> <span>name</span><span>:</span> <span>'Banana'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>3</span><span>,</span> <span>name</span><span>:</span> <span>'Orange'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>4</span><span>,</span> <span>name</span><span>:</span> <span>'Grapes'</span> <span>}</span>
  <span>]</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>ul<span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>item</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>li key<span>=</span><span>{</span>item<span>.</span>id<span>}</span><span>&gt;</span><span>{</span>item<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>  <span>// Key is the unique id of the item</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span>ul<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ShoppingList<span>;</span>
  </code></pre>
                <p>In this example:</p>
                <ul>
                    <li>We use a unique <code>id</code> for each item in the
                        <code>items</code>
                        array, which helps React distinguish between the items.
                    </li>
                </ul>
                <ul>
                    <li><strong>The key value</strong> can be any unique identifier, like
                        an ID
                        from a database, or a generated unique string.</li>
                </ul>
                <h3><strong>3. Best Practices for Keys in
                        React</strong></h3>
                <ul>
                    <li><strong>Unique within siblings</strong>: The key should be unique
                        among
                        sibling elements in a list but doesn't need to be globally unique.</li>
                </ul>
                <ul>
                    <li><strong>Avoid using indexes as keys</strong>: Using the index of an
                        item as the <code>key</code> (like <code>key={index}</code>) can cause problems, especially if
                        the
                        order of items changes. React relies on the key to identify elements, and if the items are
                        reordered,
                        the index-based keys could result in incorrect re-renders.<ul>
                            <li><strong>Use indexes only as a fallback</strong> when you
                                cannot
                                find a unique identifier (e.g., when data doesn’t have a unique ID).</li>
                        </ul>
                    </li>
                </ul>
                <h3><strong>Incorrect Key Usage with Indexes</strong>:
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ListWithIndexes</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> items <span>=</span> <span>[</span><span>'Apple'</span><span>,</span> <span>'Banana'</span><span>,</span> <span>'Orange'</span><span>,</span> <span>'Grapes'</span><span>]</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>ul<span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>(</span><span>item<span>,</span> index</span><span>)</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>li key<span>=</span><span>{</span>index<span>}</span><span>&gt;</span><span>{</span>item<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>  <span>// Avoid using index as key in lists where order can change</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span>ul<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ListWithIndexes<span>;</span>
  </code></pre>
                <h3><strong>Correct Key Usage with Unique IDs</strong>:
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ListWithIDs</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> items <span>=</span> <span>[</span>
    <span>{</span> <span>id</span><span>:</span> <span>'a1'</span><span>,</span> <span>name</span><span>:</span> <span>'Apple'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>'b2'</span><span>,</span> <span>name</span><span>:</span> <span>'Banana'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>'c3'</span><span>,</span> <span>name</span><span>:</span> <span>'Orange'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>'d4'</span><span>,</span> <span>name</span><span>:</span> <span>'Grapes'</span> <span>}</span>
  <span>]</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>ul<span>&gt;</span>
      <span>{</span>items<span>.</span><span>map</span><span>(</span><span>item</span> <span>=&gt;</span> <span>(</span>
        <span>&lt;</span>li key<span>=</span><span>{</span>item<span>.</span>id<span>}</span><span>&gt;</span><span>{</span>item<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>  <span>// Use unique id for each key</span>
      <span>)</span><span>)</span><span>}</span>
    <span>&lt;</span><span>/</span>ul<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ListWithIDs<span>;</span>
  </code></pre>
                <hr>
                <h3><strong>4. How React Uses Keys for Efficient
                        Rendering</strong></h3>
                <p>React uses the <code>key</code> to <strong>minimize
                        re-rendering</strong> when the list changes. Here's how it works:</p>
                <ul>
                    <li><strong>When the list changes</strong> (e.g., an item is added,
                        removed, or reordered), React compares the keys of the old and new lists.</li>
                </ul>
                <ul>
                    <li>If the <code>key</code> remains the same, React keeps the element
                        in
                        the DOM and updates it as needed (e.g., changing its content).</li>
                </ul>
                <ul>
                    <li>If the <code>key</code> changes (e.g., an item is reordered or
                        replaced), React removes the element from the DOM and adds the new element.</li>
                </ul>
                <p>This allows React to avoid unnecessarily
                    re-rendering all the list items and improves performance, especially when dealing with large lists.
                </p>
                <hr>
                <h3><strong>5. Example of List Update with Key</strong>
                </h3>
                <p>Imagine you have a list of items, and you want to
                    change the order of the items:</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ListUpdate</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>items<span>,</span> setItems<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>[</span>
    <span>{</span> <span>id</span><span>:</span> <span>'1'</span><span>,</span> <span>name</span><span>:</span> <span>'Apple'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>'2'</span><span>,</span> <span>name</span><span>:</span> <span>'Banana'</span> <span>}</span><span>,</span>
    <span>{</span> <span>id</span><span>:</span> <span>'3'</span><span>,</span> <span>name</span><span>:</span> <span>'Orange'</span> <span>}</span>
  <span>]</span><span>)</span><span>;</span>
  
  <span>const</span> <span>shuffleItems</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> shuffled <span>=</span> <span>[</span><span>...</span>items<span>]</span><span>;</span>
    shuffled<span>.</span><span>reverse</span><span>(</span><span>)</span><span>;</span>  <span>// Reverse the order of items</span>
    <span>setItems</span><span>(</span>shuffled<span>)</span><span>;</span>  <span>// Update the state with the new order</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>shuffleItems<span>}</span><span>&gt;</span>Shuffle<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span>ul<span>&gt;</span>
        <span>{</span>items<span>.</span><span>map</span><span>(</span><span>item</span> <span>=&gt;</span> <span>(</span>
          <span>&lt;</span>li key<span>=</span><span>{</span>item<span>.</span>id<span>}</span><span>&gt;</span><span>{</span>item<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>li<span>&gt;</span>  <span>// Key ensures React handles the reorder correctly</span>
        <span>)</span><span>)</span><span>}</span>
      <span>&lt;</span><span>/</span>ul<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ListUpdate<span>;</span>
  </code></pre>
                <ul>
                    <li>When you click the <strong>Shuffle</strong> button, the list items'
                        order is reversed.</li>
                </ul>
                <ul>
                    <li>React uses the <code>key</code> (like <code>item.id</code>) to
                        identify
                        which items have been moved, so only the reordered elements are updated in the DOM, ensuring
                        minimal
                        re-renders.</li>
                </ul>
                <hr>
                <h3><strong>Summary: Lists and Keys in React</strong>
                </h3>
                <ul>
                    <li><strong>Lists</strong> in React are rendered by iterating over
                        arrays
                        of data, typically using <code>map()</code>.</li>
                </ul>
                <ul>
                    <li><strong>Keys</strong> are required when rendering lists to help
                        React
                        identify which items have changed, been added, or removed, optimizing re-renders.</li>
                </ul>
                <ul>
                    <li><strong>Best Practices for Keys</strong>:<ul>
                            <li>Use <strong>unique values</strong> for keys (preferably
                                IDs) to
                                help React efficiently manage list updates.</li>
                        </ul>
                        <ul>
                            <li><strong>Avoid using array indices</strong> as keys unless
                                absolutely necessary because the order of items may change.</li>
                        </ul>
                    </li>
                </ul>
                <ul>
                    <li>Keys help React minimize unnecessary DOM updates and optimize
                        rendering
                        performance.</li>
                </ul>
                <p>In essence, lists and keys work together to ensure
                    that React's rendering process is efficient and that only the necessary updates are made when the
                    list
                    data changes.</p>
            </div>
        </details>
        <details>
            <summary><strong>Control and Uncontrol Components</strong></summary>
            <div class="content">
                <p><strong>controlled</strong> and
                    <strong>uncontrolled</strong> components are two approaches to managing form elements and their
                    state
                </p>
                <hr>
                <h3><strong>1. Controlled Components</strong></h3>
                <p>A <strong>controlled component</strong> is a
                    component where React controls the form element's state. The form element's value is tied to a React
                    state variable, and changes are managed through event handlers.</p>
                <h3><strong>Key Characteristics</strong>:</h3>
                <ul>
                    <li>The input value is fully controlled by React.</li>
                </ul>
                <ul>
                    <li>You use the <code>value</code> attribute of the input element to
                        bind
                        it to state.</li>
                </ul>
                <ul>
                    <li>Changes to the input trigger an event (e.g., <code>onChange</code>)
                        that updates the state.</li>
                </ul>
                <h3><strong>Example</strong>:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ControlledComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>inputValue<span>,</span> setInputValue<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>""</span><span>)</span><span>;</span>
  
  <span>const</span> <span>handleChange</span> <span>=</span> <span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setInputValue</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>;</span> <span>// Update state with input value</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>input
        type<span>=</span><span>"text"</span>
        value<span>=</span><span>{</span>inputValue<span>}</span> <span>// Controlled by React state</span>
        onChange<span>=</span><span>{</span>handleChange<span>}</span> <span>// Updates state on change</span>
      <span>/</span><span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Current Value<span>:</span> <span>{</span>inputValue<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ControlledComponent<span>;</span>
  </code></pre>
                <h3><strong>Advantages</strong>:</h3>
                <ol type="1" start="1">
                    <li>Predictable: React always knows the current value of the input.</li>
                </ol>
                <ol type="1" start="2">
                    <li>Validation: Easy to add validation logic within the <code>onChange</code> handler.</li>
                </ol>
                <ol type="1" start="3">
                    <li>Single Source of Truth: Input data is stored in the component's state, making it easier to
                        manage
                        and pass down to other components.</li>
                </ol>
                <h3><strong>Disadvantages</strong>:</h3>
                <ol type="1" start="1">
                    <li>More code: Requires extra boilerplate for managing state and handlers.</li>
                </ol>
                <ol type="1" start="2">
                    <li>Performance: For many inputs, constant state updates can have a slight performance overhead.
                    </li>
                </ol>
                <hr>
                <h3><strong>2. Uncontrolled Components</strong></h3>
                <p>An <strong>uncontrolled component</strong> is a
                    component where the form element's state is handled by the DOM itself, not React. You access the
                    input's
                    current value using a <strong>ref</strong>.</p>
                <h3><strong>Key Characteristics</strong>:</h3>
                <ul>
                    <li>The input value is controlled by the DOM.</li>
                </ul>
                <ul>
                    <li>You use a <code>ref</code> to get the value of the input when
                        needed.
                    </li>
                </ul>
                <ul>
                    <li>React does not manage the state of the input.</li>
                </ul>
                <h3><strong>Example</strong>:</h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useRef <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>UncontrolledComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> inputRef <span>=</span> <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
  
  <span>const</span> <span>handleSubmit</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>alert</span><span>(</span><span><span>`</span><span>Input Value: </span><span><span>${</span>inputRef<span>.</span>current<span>.</span>value<span>}</span></span><span>`</span></span><span>)</span><span>;</span> <span>// Access the input value directly from DOM</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>input type<span>=</span><span>"text"</span> ref<span>=</span><span>{</span>inputRef<span>}</span> <span>/</span><span>&gt;</span> <span>{</span><span>/* DOM controls the value */</span><span>}</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>handleSubmit<span>}</span><span>&gt;</span>Submit<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> UncontrolledComponent<span>;</span>
  </code></pre>
                <h3><strong>Advantages</strong>:</h3>
                <ol type="1" start="1">
                    <li>Less Boilerplate: No need to set up state or event handlers for basic inputs.</li>
                </ol>
                <ol type="1" start="2">
                    <li>Performance: Avoids frequent state updates, which can be beneficial for simple forms with many
                        fields.</li>
                </ol>
                <h3><strong>Disadvantages</strong>:</h3>
                <ol type="1" start="1">
                    <li>Less Predictable: React does not track the value, making it harder to debug or validate.</li>
                </ol>
                <ol type="1" start="2">
                    <li>Limited Control: Adding validation or dynamically changing the input value requires extra logic.
                    </li>
                </ol>
                <hr>
                <h3><strong>When to Use Controlled vs. Uncontrolled
                        Components</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td><strong>Aspect</strong></td>
                            <td><strong>Controlled</strong></td>
                            <td><strong>Uncontrolled</strong></td>
                        </tr>
                        <tr>
                            <td><strong>Form State Management</strong></td>
                            <td>Ideal when you need to track and manipulate form data.</td>
                            <td>Use for simple forms or uncontrolled inputs like file uploads.</td>
                        </tr>
                        <tr>
                            <td><strong>Validation</strong></td>
                            <td>Easy to add validation logic within the component.</td>
                            <td>Requires manual validation logic after retrieving the value.</td>
                        </tr>
                        <tr>
                            <td><strong>Code Complexity</strong></td>
                            <td>More boilerplate due to state management.</td>
                            <td>Simpler for basic use cases.</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Slightly slower due to React state updates.</td>
                            <td>Faster for forms with many fields.</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Hybrid Approach</strong></h3>
                <p>In some cases, you might use a hybrid approach where
                    certain fields are uncontrolled for simplicity, but the form as a whole is controlled (e.g.,
                    handling
                    form submission with React state).</p>
            </div>
        </details>
        <details>
            <summary><strong>Event handing in class and functional components.</strong></summary>
            <div class="content">
                <h3><strong>Event Handling in React: Class vs
                        Functional Components</strong></h3>
                <p>In React, <strong>event handling</strong> refers to
                    the process of listening for and responding to user interactions like clicks, keyboard inputs, mouse
                    movements, and other events. Handling events in React is similar to handling events in plain HTML,
                    but
                    with some key differences due to React's component-based architecture and its virtual DOM.</p>
                <p>Event handling in React can be done in both
                    <strong>Class components</strong> and <strong>Functional components</strong>. The approaches differ
                    slightly in syntax, particularly because <strong>Class components</strong> use methods, while
                    <strong>Functional components</strong> often use hooks.
                </p>
                <hr>
                <h3><strong>Event Handling in Class Components</strong>
                </h3>
                <p>In <strong>Class components</strong>, event handling
                    is done by defining methods inside the class and binding them to the component's context (if
                    necessary).
                    The event handlers are then passed to the relevant JSX elements as props.</p>
                <h3><strong>Steps for Event Handling in Class
                        Components:</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Define the event handler as a class method.</strong></li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Bind the event handler to </strong><code><strong>this</strong></code><strong> (if using
                            an
                            older version of React, i.e., React 16 and below).</strong></li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Pass the event handler to the JSX element in the
                        </strong><code><strong>onEventName</strong></code><strong> prop.</strong></li>
                </ol>
                <h3><strong>Example: Event Handling in Class
                        Component</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>class</span> <span>MyComponent</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span>
      <span>count</span><span>:</span> <span>0</span><span>,</span>
    <span>}</span><span>;</span>
  
    <span>// Binding the event handler to 'this' (if needed)</span>
    <span>this</span><span>.</span>handleClick <span>=</span> <span>this</span><span>.</span><span>handleClick</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>handleClick</span><span>(</span><span>)</span> <span>{</span>
    <span>// Updating state when the button is clicked</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> <span>count</span><span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> <span>}</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>handleClick<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
        <span>&lt;</span>p<span>&gt;</span>Count<span>:</span> <span>{</span><span>this</span><span>.</span>state<span>.</span>count<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><strong>Method Binding
                            (</strong><code><strong>this.handleClick.bind(this)</strong></code><strong>)</strong>: In
                        JavaScript
                        classes, methods are not automatically bound to the instance of the class. This is why we bind
                        the
                        method <code>handleClick</code> to the class instance (<code>this</code>).</li>
                </ul>
                <ul>
                    <li><code><strong>onClick={this.handleClick}</strong></code>: The
                        method is
                        passed as an event handler for the <code>onClick</code> event of the button. When the button is
                        clicked, the <code>handleClick</code> method is called, which updates the state.</li>
                </ul>
                <h3><strong>Key Points for Event Handling in Class
                        Components:</strong></h3>
                <ul>
                    <li>In older React versions (pre-16.8), you need to bind event handlers
                        to
                        <code>this</code> in the constructor.
                    </li>
                </ul>
                <ul>
                    <li>You define event handlers as methods inside the class.</li>
                </ul>
                <ul>
                    <li>Event handlers are passed to JSX elements as props (e.g.,
                        <code>onClick={this.handleClick}</code>).
                    </li>
                </ul>
                <hr>
                <h3><strong>Event Handling in Functional
                        Components</strong></h3>
                <p>In <strong>Functional components</strong>, event
                    handling is simpler and more concise due to the use of <strong>hooks</strong>, particularly
                    <code>useState</code> for managing state. Since functional components don't have the concept of
                    class
                    methods, event handlers are typically functions defined within the component.
                </p>
                <h3><strong>Steps for Event Handling in Functional
                        Components:</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Define the event handler as a function inside the component.</strong></li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Use state hooks (e.g., </strong><code><strong>useState</strong></code><strong>) to
                            manage
                            state.</strong></li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Pass the event handler to the JSX element in the
                        </strong><code><strong>onEventName</strong></code><strong> prop.</strong></li>
                </ol>
                <h3><strong>Example: Event Handling in Functional
                        Component</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>// Declaring state using the useState hook</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>// Event handler function</span>
  <span>const</span> <span>handleClick</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span> <span>// Updating the state when the button is clicked</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>handleClick<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><code><strong>useState(0)</strong></code>: The
                        <code>useState</code>
                        hook is used to declare the <code>count</code> state, initializing it to 0.
                    </li>
                </ul>
                <ul>
                    <li><code><strong>handleClick</strong></code><strong>
                            function</strong>:
                        The event handler is defined as a simple function inside the component, which updates the state
                        when
                        invoked.</li>
                </ul>
                <ul>
                    <li><code><strong>onClick={handleClick}</strong></code>: The function
                        <code>handleClick</code> is passed as the event handler for the <code>onClick</code> event of
                        the
                        button.
                    </li>
                </ul>
                <h3><strong>Key Points for Event Handling in Functional
                        Components:</strong></h3>
                <ul>
                    <li>Event handlers are simple functions defined directly within the
                        function component.</li>
                </ul>
                <ul>
                    <li>You can manage component state using the <code>useState</code>
                        hook.
                    </li>
                </ul>
                <ul>
                    <li>No need for <code>this</code> binding, as there is no concept of
                        instance methods.</li>
                </ul>
                <hr>
                <h3><strong>Event Handling: Key Differences between
                        Class and Functional Components</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Method Binding:</strong>
                        <ul>
                            <li><strong>Class Components</strong>: In class components, you
                                need to
                                bind methods to the component instance (if you're using older React versions). This
                                ensures that
                                <code>this</code> refers to the class instance inside the method.
                            </li>
                        </ul>
                        <ul>
                            <li><strong>Functional Components</strong>: In functional
                                components,
                                there’s no <code>this</code>, so you don't need to bind methods. Event handler functions
                                are
                                defined directly inside the component.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>State Management:</strong>
                        <ul>
                            <li><strong>Class Components</strong>: State is managed using
                                <code>this.state</code> and updated via <code>this.setState()</code>.
                            </li>
                        </ul>
                        <ul>
                            <li><strong>Functional Components</strong>: State is managed
                                using
                                React hooks like <code>useState</code>, making the syntax simpler.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Simplicity and Readability:</strong>
                        <ul>
                            <li><strong>Class Components</strong>: Event handlers are often
                                methods
                                within the class, which can lead to more verbose code.</li>
                        </ul>
                        <ul>
                            <li><strong>Functional Components</strong>: Event handlers are
                                simply
                                functions within the body of the component, making the code more concise and easier to
                                read.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Performance:</strong>
                        <ul>
                            <li><strong>Class Components</strong>: Each method is created
                                as part
                                of the class and needs to be bound (if necessary). This can lead to minor overhead.</li>
                        </ul>
                        <ul>
                            <li><strong>Functional Components</strong>: Functional
                                components are
                                generally simpler and have less overhead, especially with React hooks. However, it's
                                essential to
                                use memoization techniques (<code>useCallback</code>, <code>React.memo</code>) when
                                passing event
                                handlers as props to prevent unnecessary re-renders.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Passing Parameters to Event
                        Handlers</strong></h3>
                <p>Sometimes you might need to pass parameters to the
                    event handler. Here's how it's done in both class and functional components:</p>
                <h3><strong>In Class Components:</strong></h3>
                <p>To pass additional parameters to an event handler,
                    you can use an anonymous function inside the JSX.</p>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>handleClick</span><span>(</span><span>id<span>,</span> event</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Button clicked with id:'</span><span>,</span> id<span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>this</span><span>.</span><span>handleClick</span><span>(</span><span>1</span><span>,</span> event<span>)</span><span>}</span><span>&gt;</span>Click Me<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  </code></pre>
                <h3><strong>In Functional Components:</strong></h3>
                <p>In functional components, you can also use an
                    anonymous function or directly pass the parameters in the event handler.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>handleClick</span> <span>=</span> <span>(</span><span>id<span>,</span> event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Button clicked with id:'</span><span>,</span> id<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span><span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>handleClick</span><span>(</span><span>1</span><span>,</span> event<span>)</span><span>}</span><span>&gt;</span>Click Me<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <hr>
                <h3><strong>Summary of Key Differences:</strong></h3>
                <table>
                    <tbody>
                        <tr>
                            <td>Aspect</td>
                            <td><strong>Class Component</strong></td>
                            <td><strong>Functional Component</strong></td>
                        </tr>
                        <tr>
                            <td><strong>State Management</strong></td>
                            <td><code>this.state</code> and <code>this.setState()</code></td>
                            <td><code>useState()</code> hook</td>
                        </tr>
                        <tr>
                            <td><strong>Method Binding</strong></td>
                            <td>Necessary in older React versions
                                (<code>this.handleClick.bind(this)</code>)
                            </td>
                            <td>No binding needed</td>
                        </tr>
                        <tr>
                            <td><strong>Event Handler Definition</strong></td>
                            <td>As a class method</td>
                            <td>As a function inside the component</td>
                        </tr>
                        <tr>
                            <td><strong>Simplicity</strong></td>
                            <td>More verbose, especially with binding</td>
                            <td>More concise, easier to manage</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>May require optimization with <code>shouldComponentUpdate</code></td>
                            <td>Simplified with <code>useEffect</code> and hooks</td>
                        </tr>
                    </tbody>
                </table>
                <hr>
                <h3><strong>Conclusion</strong></h3>
                <ul>
                    <li><strong>Class Components</strong> use methods to handle events, and
                        these methods must be bound to the instance (in older versions of React).</li>
                </ul>
                <ul>
                    <li><strong>Functional Components</strong> use simple functions for
                        event
                        handling, often with the help of hooks like <code>useState</code> to manage state. The
                        functional
                        approach is more concise and modern, making it the preferred choice in newer React applications.
                    </li>
                </ul>
                <p>Both class and functional components provide a
                    similar mechanism for handling events, but functional components, along with hooks, offer a cleaner
                    and
                    more straightforward syntax for managing events and state in React.</p>
            </div>
        </details>
        <details>
            <summary><strong>Form in React</strong></summary>
            <div class="content">
                <h3><strong>Forms in React</strong></h3>
                <p>In React, forms are used to capture and handle user
                    input. A React form is similar to HTML forms, but React takes control of the form elements by
                    managing
                    their state. React allows you to create controlled and uncontrolled components for forms, giving you
                    flexibility on how to handle form data.</p>
                <hr>
                <h3><strong>1. Controlled Components</strong></h3>
                <p>A <strong>controlled component</strong> is a form
                    element whose value is controlled by the state in a React component. This means that React manages
                    the
                    form data, and every form element's state (like an input field) is updated via React state.</p>
                <p>In controlled components, you will bind the input
                    value to a React state variable and handle the <code>onChange</code> event to update the state
                    whenever
                    the user types something.</p>
                <h3><strong>Example: Controlled Input in React</strong>
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ControlledForm</span><span>(</span><span>)</span> <span>{</span>
  <span>// State to manage the input value</span>
  <span>const</span> <span>[</span>inputValue<span>,</span> setInputValue<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  
  <span>// Handle input change</span>
  <span>const</span> <span>handleChange</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setInputValue</span><span>(</span>event<span>.</span>target<span>.</span>value<span>)</span><span>;</span>  <span>// Update state on input change</span>
  <span>}</span><span>;</span>
  
  <span>// Handle form submission</span>
  <span>const</span> <span>handleSubmit</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
    <span>alert</span><span>(</span><span>'Form submitted with input: '</span> <span>+</span> inputValue<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>form onSubmit<span>=</span><span>{</span>handleSubmit<span>}</span><span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>
        <span>Name</span><span>:</span>
        <span>&lt;</span>input
          type<span>=</span><span>"text"</span>
          value<span>=</span><span>{</span>inputValue<span>}</span>       <span>// The input value is controlled by the state</span>
          onChange<span>=</span><span>{</span>handleChange<span>}</span>  <span>// Update the state when the input changes</span>
        <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>button type<span>=</span><span>"submit"</span><span>&gt;</span>Submit<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>form<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ControlledForm<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li>The <code>inputValue</code> state is initialized with an empty
                        string
                        and controls the input field.</li>
                </ul>
                <ul>
                    <li>The <code>handleChange</code> function updates the
                        <code>inputValue</code> state every time the user types into the input field.
                    </li>
                </ul>
                <ul>
                    <li>The form submission is handled in the <code>handleSubmit</code>
                        function, and the current value of <code>inputValue</code> is displayed in an alert.</li>
                </ul>
                <p>In a controlled component:</p>
                <ul>
                    <li>The value of the form element is driven by React state.</li>
                </ul>
                <ul>
                    <li>You can apply custom validation, manipulate data, and perform
                        actions
                        on form submission.</li>
                </ul>
                <hr>
                <h3><strong>2. Uncontrolled Components</strong></h3>
                <p>An <strong>uncontrolled component</strong> is a form
                    element whose value is managed by the DOM itself rather than by React state. React provides a
                    <code>ref</code> to directly access the DOM nodes, allowing you to get the current value of the
                    input
                    field when the form is submitted.
                </p>
                <p>In uncontrolled components, you don’t need to handle
                    the state directly. Instead, you access the input's value using <code>ref</code> when necessary.</p>
                <h3><strong>Example: Uncontrolled Input in
                        React</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useRef <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>UncontrolledForm</span><span>(</span><span>)</span> <span>{</span>
  <span>// Use useRef to create a reference for the input element</span>
  <span>const</span> inputRef <span>=</span> <span>useRef</span><span>(</span><span>)</span><span>;</span>
  
  <span>// Handle form submission</span>
  <span>const</span> <span>handleSubmit</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
    <span>alert</span><span>(</span><span>'Form submitted with input: '</span> <span>+</span> inputRef<span>.</span>current<span>.</span>value<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>form onSubmit<span>=</span><span>{</span>handleSubmit<span>}</span><span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>
        <span>Name</span><span>:</span>
        <span>&lt;</span>input
          type<span>=</span><span>"text"</span>
          ref<span>=</span><span>{</span>inputRef<span>}</span>  <span>// Access the input value through the ref</span>
        <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>button type<span>=</span><span>"submit"</span><span>&gt;</span>Submit<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>form<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> UncontrolledForm<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li>We create a reference to the <code>&lt;input&gt;</code> element
                        using
                        <code>useRef()</code>.
                    </li>
                </ul>
                <ul>
                    <li>During form submission, we access the input value via
                        <code>inputRef.current.value</code> and display it in an alert.
                    </li>
                </ul>
                <ul>
                    <li>In uncontrolled components, the form elements are not controlled by
                        React state, and React uses the DOM to manage their value.</li>
                </ul>
                <hr>
                <h3><strong>3. Why Use Controlled vs Uncontrolled
                        Components?</strong></h3>
                <h3><strong>Advantages of Controlled
                        Components:</strong></h3>
                <ul>
                    <li><strong>Consistency:</strong> Since React state drives the form
                        elements, you can easily access and manipulate the input value in the state. You have full
                        control
                        over the form data.</li>
                </ul>
                <ul>
                    <li><strong>Validation:</strong> It's easier to perform real-time
                        validation and updates because React controls the form state.</li>
                </ul>
                <ul>
                    <li><strong>Data Management:</strong> You can easily integrate the form
                        data with other React components, send it to a server, or manage complex form behaviors.</li>
                </ul>
                <h3><strong>Advantages of Uncontrolled
                        Components:</strong></h3>
                <ul>
                    <li><strong>Simplicity:</strong> If you don’t need complex interactions
                        with the form data (like validation, real-time updates, or processing), uncontrolled components
                        can be
                        simpler to use.</li>
                </ul>
                <ul>
                    <li><strong>Performance:</strong> In some cases, uncontrolled
                        components
                        may be more performant because React doesn't need to re-render on every keystroke or change to
                        the
                        form element's value.</li>
                </ul>
                <ul>
                    <li><strong>Direct DOM Access:</strong> It gives you access to the DOM
                        elements, which is useful when dealing with legacy code or non-React libraries.</li>
                </ul>
                <hr>
                <h3><strong>4. Form Handling and Multiple
                        Inputs</strong></h3>
                <p>You can manage multiple inputs (text, checkboxes,
                    radio buttons, etc.) within a single form by keeping the state for each input. This is often done
                    using
                    an object to hold all form data.</p>
                <h3><strong>Example: Multiple Controlled
                        Inputs</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MultipleInputsForm</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>formData<span>,</span> setFormData<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>{</span>
    <span>name</span><span>:</span> <span>''</span><span>,</span>
    <span>age</span><span>:</span> <span>''</span><span>,</span>
    <span>gender</span><span>:</span> <span>'male'</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
  
  <span>// Handle input change</span>
  <span>const</span> <span>handleChange</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>const</span> <span>{</span> name<span>,</span> value <span>}</span> <span>=</span> event<span>.</span>target<span>;</span>
    <span>setFormData</span><span>(</span><span>{</span>
      <span>...</span>formData<span>,</span>    <span>// Spread the existing formData</span>
      <span>[</span>name<span>]</span><span>:</span> value   <span>// Update the value for the input that was changed</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>// Handle form submission</span>
  <span>const</span> <span>handleSubmit</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
    <span>alert</span><span>(</span><span>'Form submitted with data: '</span> <span>+</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>formData<span>)</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>form onSubmit<span>=</span><span>{</span>handleSubmit<span>}</span><span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>
        <span>Name</span><span>:</span>
        <span>&lt;</span>input
          type<span>=</span><span>"text"</span>
          name<span>=</span><span>"name"</span>
          value<span>=</span><span>{</span>formData<span>.</span>name<span>}</span>  <span>// Bind the value to formData.name</span>
          onChange<span>=</span><span>{</span>handleChange<span>}</span>
        <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>
        <span>Age</span><span>:</span>
        <span>&lt;</span>input
          type<span>=</span><span>"number"</span>
          name<span>=</span><span>"age"</span>
          value<span>=</span><span>{</span>formData<span>.</span>age<span>}</span>  <span>// Bind the value to formData.age</span>
          onChange<span>=</span><span>{</span>handleChange<span>}</span>
        <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>
        <span>Gender</span><span>:</span>
        <span>&lt;</span>select
          name<span>=</span><span>"gender"</span>
          value<span>=</span><span>{</span>formData<span>.</span>gender<span>}</span>  <span>// Bind the value to formData.gender</span>
          onChange<span>=</span><span>{</span>handleChange<span>}</span>
        <span>&gt;</span>
          <span>&lt;</span>option value<span>=</span><span>"male"</span><span>&gt;</span>Male<span>&lt;</span><span>/</span>option<span>&gt;</span>
          <span>&lt;</span>option value<span>=</span><span>"female"</span><span>&gt;</span>Female<span>&lt;</span><span>/</span>option<span>&gt;</span>
          <span>&lt;</span>option value<span>=</span><span>"other"</span><span>&gt;</span>Other<span>&lt;</span><span>/</span>option<span>&gt;</span>
        <span>&lt;</span><span>/</span>select<span>&gt;</span>
      <span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>button type<span>=</span><span>"submit"</span><span>&gt;</span>Submit<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>form<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MultipleInputsForm<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li>The form data is stored in a <code>formData</code> state object,
                        where
                        each key represents a form field (<code>name</code>, <code>age</code>, <code>gender</code>).
                    </li>
                </ul>
                <ul>
                    <li>The <code>handleChange</code> function updates the corresponding
                        field
                        in the <code>formData</code> object when the user types or selects an option.</li>
                </ul>
                <ul>
                    <li>When the form is submitted, the complete form data is displayed in
                        an
                        alert.</li>
                </ul>
                <hr>
                <h3><strong>5. Form Validation in React</strong></h3>
                <p>Form validation in React can be performed either in
                    the form’s <code>onSubmit</code> handler or through event listeners (like <code>onChange</code>).
                    You
                    can check whether the user input meets the required conditions before submitting the form.</p>
                <h3><strong>Example: Simple Form Validation</strong>
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>ValidationForm</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>name<span>,</span> setName<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span>error<span>,</span> setError<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  
  <span>const</span> <span>handleSubmit</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=&gt;</span> <span>{</span>
    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span><span>;</span>
  
    <span>if</span> <span>(</span>name <span>===</span> <span>''</span><span>)</span> <span>{</span>
      <span>setError</span><span>(</span><span>'Name is required'</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>setError</span><span>(</span><span>''</span><span>)</span><span>;</span>
      <span>alert</span><span>(</span><span>'Form submitted with name: '</span> <span>+</span> name<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>form onSubmit<span>=</span><span>{</span>handleSubmit<span>}</span><span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>
        <span>Name</span><span>:</span>
        <span>&lt;</span>input
          type<span>=</span><span>"text"</span>
          value<span>=</span><span>{</span>name<span>}</span>
          onChange<span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>setName</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span>
        <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>{</span>error <span>&amp;&amp;</span> <span>&lt;</span>p style<span>=</span><span>{</span><span>{</span> <span>color</span><span>:</span> <span>'red'</span> <span>}</span><span>}</span><span>&gt;</span><span>{</span>error<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span><span>}</span>  <span>{</span><span>/* Display error message */</span><span>}</span>
      <span>&lt;</span>button type<span>=</span><span>"submit"</span><span>&gt;</span>Submit<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>form<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> ValidationForm<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li>If the user attempts to submit the form with an empty
                        <code>name</code>
                        field, an error message is shown below the input.
                    </li>
                </ul>
                <ul>
                    <li>You can perform validation logic inside <code>handleSubmit</code>
                        or
                        use the <code>onChange</code> event to validate as the user types.</li>
                </ul>
                <hr>
                <h3><strong>Summary</strong></h3>
                <ul>
                    <li><strong>Controlled Components</strong>: The form element's value is
                        controlled by React state. This allows easy access to and manipulation of the form data.</li>
                </ul>
                <ul>
                    <li><strong>Uncontrolled Components</strong>: The form element's value
                        is
                        managed by the DOM, and React uses refs to access the value when needed.</li>
                </ul>
                <ul>
                    <li><strong>Form Handling</strong>: You can use <code>useState</code>
                        to
                        manage the form data, <code>onChange</code> to capture user input, and <code>onSubmit</code> to
                        handle
                        form submission.</li>
                </ul>
                <ul>
                    <li><strong>Form Validation</strong>: React allows you to easily
                        validate
                        form inputs before submission and provide real-time feedback to the user.</li>
                </ul>
                <p>Forms in React provide flexibility and control,
                    enabling you to create dynamic and interactive UIs that respond to user input.</p>
            </div>
        </details>
        <details>
            <summary><strong>Dom handing</strong></summary>
            <div class="content">
                <p>In React, <strong>DOM handling</strong> is
                    abstracted and optimized through the <strong>Virtual DOM</strong>. React provides a declarative
                    approach
                    to managing the DOM, meaning you describe what the UI should look like at any given time, and React
                    takes care of updating the actual DOM efficiently when state or props change.</p>
                <p>Unlike traditional JavaScript, where you manually
                    manipulate the DOM (e.g., with <code>document.getElementById</code>), React allows you to
                    declaratively
                    express the UI in terms of components, and React handles the underlying DOM updates for you.</p>
                <hr>
                <h3><strong>1. Virtual DOM in React</strong></h3>
                <p>Before diving into DOM manipulation specifics, it's
                    essential to understand the concept of <strong>Virtual DOM</strong>.</p>
                <ul>
                    <li>The <strong>Virtual DOM (VDOM)</strong> is an in-memory
                        representation
                        of the real DOM elements. When the state of an object changes, React updates the Virtual DOM
                        first,
                        and then it compares the updated Virtual DOM with the previous version (a process called
                        <strong>Reconciliation</strong>).
                    </li>
                </ul>
                <ul>
                    <li>React then calculates the <strong>difference</strong> (called a
                        "diffing algorithm") and updates only the parts of the actual DOM that need to change. This
                        makes
                        React highly efficient, as it minimizes the number of updates to the real DOM.</li>
                </ul>
                <hr>
                <h3><strong>2. DOM Access in React (Refs)</strong></h3>
                <p>While React abstracts most DOM manipulation, there
                    are cases where you need direct access to DOM elements. In these cases, React provides a mechanism
                    called <strong>Refs</strong>.</p>
                <h3><strong>What are Refs?</strong></h3>
                <p>Refs provide a way to access DOM nodes or React
                    elements directly. They are often used when you need to:</p>
                <ul>
                    <li>Manage focus on form elements.</li>
                </ul>
                <ul>
                    <li>Trigger animations.</li>
                </ul>
                <ul>
                    <li>Directly manipulate a child component.</li>
                </ul>
                <ul>
                    <li>Integrate with third-party DOM libraries.</li>
                </ul>
                <h3><strong>How to Use Refs in React:</strong></h3>
                <p>In React, <strong>refs</strong> are created using
                    <code>React.createRef()</code> in class components or <code>useRef()</code> in functional
                    components.
                </p>
                <hr>
                <h3><strong>3. Using Refs in Class Components</strong>
                </h3>
                <p>In class components, you create refs using
                    <code>React.createRef()</code>.
                </p>
                <h3><strong>Example: Using Refs in Class
                        Components</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>class</span> <span>MyComponent</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>// Create a ref to access the input element</span>
    <span>this</span><span>.</span>inputRef <span>=</span> React<span>.</span><span>createRef</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>handleFocus</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Access the DOM node directly and focus it</span>
    <span>this</span><span>.</span>inputRef<span>.</span>current<span>.</span><span>focus</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>input ref<span>=</span><span>{</span><span>this</span><span>.</span>inputRef<span>}</span> type<span>=</span><span>"text"</span> placeholder<span>=</span><span>"Focus me"</span> <span>/</span><span>&gt;</span>
        <span>&lt;</span>button onClick<span>=</span><span>{</span><span>this</span><span>.</span>handleFocus<span>}</span><span>&gt;</span>Focus Input<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>)</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><code>this.inputRef = React.createRef()</code> creates a ref.</li>
                </ul>
                <ul>
                    <li>The <code>ref={this.inputRef}</code> is attached to the input
                        element
                        in the JSX.</li>
                </ul>
                <ul>
                    <li><code>this.inputRef.current.focus()</code> is used to directly
                        focus on
                        the input field when the button is clicked.</li>
                </ul>
                <hr>
                <h3><strong>4. Using Refs in Functional
                        Components</strong></h3>
                <p>In functional components, you use the
                    <code>useRef()</code> hook to create refs.
                </p>
                <h3><strong>Example: Using Refs in Functional
                        Components</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useRef <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>// Create a ref using the useRef hook</span>
  <span>const</span> inputRef <span>=</span> <span>useRef</span><span>(</span><span>null</span><span>)</span><span>;</span>
  
  <span>const</span> <span>handleFocus</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Access the DOM node directly and focus it</span>
    inputRef<span>.</span>current<span>.</span><span>focus</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>input ref<span>=</span><span>{</span>inputRef<span>}</span> type<span>=</span><span>"text"</span> placeholder<span>=</span><span>"Focus me"</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>handleFocus<span>}</span><span>&gt;</span>Focus Input<span>&lt;</span><span>/</span>button<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><code>useRef(null)</code> creates a ref in the functional
                        component.
                    </li>
                </ul>
                <ul>
                    <li>The <code>ref={inputRef}</code> attaches the ref to the input
                        element.
                    </li>
                </ul>
                <ul>
                    <li><code>inputRef.current.focus()</code> is used to focus on the input
                        element when the button is clicked.</li>
                </ul>
                <hr>
                <h3><strong>5. DOM Manipulation with
                    </strong><code><strong>useEffect</strong></code></h3>
                <p>In React functional components, you can manipulate
                    the DOM after the component has been mounted or updated by using the
                    <code><strong>useEffect</strong></code><strong> hook</strong>. This allows you to perform side
                    effects
                    like DOM manipulations after React has completed updating the DOM.
                </p>
                <h3><strong>Example: Using
                    </strong><code><strong>useEffect</strong></code><strong> for DOM Manipulation</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Manipulate the DOM after component mounts</span>
    document<span>.</span>title <span>=</span> <span>'New Page Title'</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span> <span>// Empty dependency array ensures this runs only once after the initial render</span>
  
  <span>return</span> <span>&lt;</span>div<span>&gt;</span>Check the document title<span>!</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><code>useEffect</code> is used to perform side effects in
                        functional
                        components.</li>
                </ul>
                <ul>
                    <li>In this example, we update the <code>document.title</code> after
                        the
                        component mounts.</li>
                </ul>
                <ul>
                    <li>The empty dependency array <code>[]</code> ensures this effect runs
                        only once (like <code>componentDidMount</code> in class components).</li>
                </ul>
                <hr>
                <h3><strong>6. Manipulating DOM with Event
                        Handlers</strong></h3>
                <p>Event handlers in React handle user interactions
                    like clicks, form submissions, etc. React automatically listens for events on the Virtual DOM, and
                    when
                    the event is triggered, React updates the Virtual DOM and then synchronizes changes to the real DOM.
                </p>
                <h3><strong>Example: Event Handling with DOM
                        Updates</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>const</span> <span>handleClick</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>button onClick<span>=</span><span>{</span>handleClick<span>}</span><span>&gt;</span>Increment Count<span>&lt;</span><span>/</span>button<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li>The <code>handleClick</code> event handler is called when the
                        button is
                        clicked.</li>
                </ul>
                <ul>
                    <li><code>setCount(count + 1)</code> updates the state, which triggers
                        a
                        re-render of the component.</li>
                </ul>
                <ul>
                    <li>React efficiently updates the real DOM by only changing the parts
                        of
                        the DOM that are affected by the state change.</li>
                </ul>
                <hr>
                <h3><strong>7. Direct DOM Manipulation (Not Recommended
                        in React)</strong></h3>
                <p>While React encourages using the Virtual DOM and
                    state to manage UI updates, there may be rare cases where you want to manually manipulate the DOM
                    (for
                    example, when integrating with third-party libraries or performing complex animations).</p>
                <p>However, direct DOM manipulation in React is
                    discouraged because it can conflict with React's Virtual DOM and may lead to performance issues.</p>
                <p>For example, manipulating the DOM directly using
                    <code>document.querySelector</code> in a React component:
                </p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>MyComponent</span><span>(</span><span>)</span> <span>{</span>
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Directly manipulating the DOM (Not recommended in React)</span>
    <span>const</span> button <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'button'</span><span>)</span><span>;</span>
    button<span>.</span>style<span>.</span>backgroundColor <span>=</span> <span>'blue'</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span>button<span>&gt;</span>Click Me<span>&lt;</span><span>/</span>button<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> MyComponent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><code>document.querySelector</code> is used to select the button
                        element and modify its style.</li>
                </ul>
                <ul>
                    <li>While this works, React encourages you to manipulate the DOM
                        declaratively through state and props rather than directly.</li>
                </ul>
                <hr>
                <h3><strong>Best Practices for DOM Handling in
                        React</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Prefer Declarative Approach</strong>: Always try to manage UI and DOM updates through
                        React's state and props rather than direct DOM manipulation. This keeps your app predictable and
                        improves performance.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Use Refs Only When Necessary</strong>: Refs are useful for managing focus, animations,
                        or
                        third-party libraries that require direct DOM access. Avoid overusing refs as they can break the
                        declarative nature of React.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Avoid Direct DOM Manipulation</strong>: Manipulating the DOM outside of React’s control
                        (e.g., using <code>document.getElementById</code> or <code>document.querySelector</code>) can
                        lead to
                        performance issues and bugs. React's Virtual DOM system is optimized to update the DOM in the
                        most
                        efficient way possible, so let React handle it.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Use </strong><code><strong>useEffect</strong></code><strong> for Side Effects</strong>:
                        If
                        you need to interact with the DOM after the component has rendered (e.g., updating
                        <code>document.title</code> or integrating with non-React libraries), use the
                        <code>useEffect</code>
                        hook in functional components.
                    </li>
                </ol>
                <hr>
                <h3><strong>Conclusion</strong></h3>
                <p>In React, DOM handling is abstracted away through
                    the <strong>Virtual DOM</strong> to optimize performance. React uses declarative programming,
                    meaning
                    you describe the UI, and React updates the real DOM efficiently. When direct DOM manipulation is
                    necessary, React provides tools like <strong>refs</strong> and the
                    <code><strong>useEffect</strong></code><strong> hook</strong> to give you controlled access to the
                    DOM.
                    Directly manipulating the DOM (without using React's built-in tools) is not recommended because it
                    can
                    interfere with React's virtual DOM mechanism and reduce the performance benefits React provides.
                </p>
            </div>
        </details>
        <details>
            <summary><strong>React Context API</strong></summary>
            <div class="content">
                <p>The <strong>React Context API</strong> is a powerful feature in React that allows you to share state or values globally across components without having to pass props manually through every level of the component tree. It&#39;s especially useful when you have global data that needs to be accessed by many components at different levels, like user authentication status, themes, language settings, or any other kind of shared state.</p>
<h3 id="key-concepts-of-react-context-api">Key Concepts of React Context API:</h3>
<ol>
<li><strong>Context</strong>: A context object is created using <code>React.createContext()</code>. This object is used to define and share a value (state) across the application.</li>
<li><strong>Provider</strong>: The <code>Provider</code> component is used to make the context value available to all components in the tree that need it. It’s placed higher in the component tree and wraps other components.</li>
<li><strong>Consumer</strong>: The <code>Consumer</code> component allows any component to access the value from the context. However, this is less commonly used with the introduction of the <code>useContext</code> hook.</li>
<li><strong>useContext Hook</strong>: This hook allows function components to access the context directly without needing a <code>Consumer</code>.</li>
</ol>
<h3 id="steps-to-use-the-react-context-api">Steps to Use the React Context API:</h3>
<h4 id="1-create-a-context">1. Create a Context:</h4>
<p>To create a context, you use <code>React.createContext()</code>. This function returns an object with two components:</p>
<ul>
<li>A <code>Provider</code> to supply the value to the component tree.</li>
<li>A <code>Consumer</code> to consume the value from the context.</li>
</ul>
<pre><code class="language-javascript">import React from &#39;react&#39;;

const MyContext = React.createContext();
</code></pre>
<h4 id="2-wrap-your-application-with-the-provider">2. Wrap Your Application with the Provider:</h4>
<p>The <code>Provider</code> component is used to make a value available to the entire component tree, or to specific components wrapped by it.</p>
<pre><code class="language-javascript">import React, { useState } from &#39;react&#39;;

// Create a context
const MyContext = React.createContext();

function App() {
  const [user, setUser] = useState(&#39;John Doe&#39;);

  return (
    // Wrap the application or a part of it with the Provider
    &lt;MyContext.Provider value={{ user, setUser }}&gt;
      &lt;ComponentA /&gt;
    &lt;/MyContext.Provider&gt;
  );
}
</code></pre>
<p>In this example, the <code>user</code> and <code>setUser</code> values are provided to all components inside <code>MyContext.Provider</code>.</p>
<h4 id="3-accessing-the-context-value-in-components">3. Accessing the Context Value in Components:</h4>
<h5 id="option-1-using-usecontext-hook-recommended-for-function-components">Option 1: Using <code>useContext</code> Hook (Recommended for function components)</h5>
<p>The <code>useContext</code> hook provides an easy way to consume context values in functional components.</p>
<pre><code class="language-javascript">import React, { useContext } from &#39;react&#39;;

// Function component that consumes the context value
function ComponentA() {
  const { user, setUser } = useContext(MyContext);

  return (
    &lt;div&gt;
      &lt;p&gt;Welcome, {user}&lt;/p&gt;
      &lt;button onClick={() =&gt; setUser(&#39;Jane Doe&#39;)}&gt;Change User&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>In this example, <code>useContext(MyContext)</code> accesses the <code>user</code> and <code>setUser</code> values that were provided by the <code>Provider</code>. Whenever <code>setUser</code> is called, it will update the state in the <code>App</code> component, and all components consuming the context will re-render with the new value.</p>
<h5 id="option-2-using-consumer-older-approach">Option 2: Using <code>Consumer</code> (Older approach)</h5>
<p>Before <code>useContext</code>, the <code>Consumer</code> component was used to access context values. While still valid, it is less common today in favor of the hook.</p>
<pre><code class="language-javascript">function ComponentA() {
  return (
    &lt;MyContext.Consumer&gt;
      {({ user, setUser }) =&gt; (
        &lt;div&gt;
          &lt;p&gt;Welcome, {user}&lt;/p&gt;
          &lt;button onClick={() =&gt; setUser(&#39;Jane Doe&#39;)}&gt;Change User&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/MyContext.Consumer&gt;
  );
}
</code></pre>
<p>In this example, the <code>Consumer</code> component is used to access the context value. It takes a function as a child, which receives the context value (<code>user</code> and <code>setUser</code>) as an argument.</p>
<h4 id="4-default-value-for-context">4. Default Value for Context:</h4>
<p>When you create a context using <code>React.createContext()</code>, you can pass a default value. This default value is used if no <code>Provider</code> is found in the component tree, but it&#39;s typically used for situations where the context is intended to be used outside of React&#39;s typical state management, such as for testing.</p>
<pre><code class="language-javascript">const MyContext = React.createContext({ user: &#39;Guest&#39;, setUser: () =&gt; {} });
</code></pre>
<h3 id="example-a-complete-example-of-react-context-api">Example: A Complete Example of React Context API</h3>
<p>Here’s an example of a simple user authentication scenario using the Context API:</p>
<pre><code class="language-javascript">import React, { useState, useContext } from &#39;react&#39;;

// Create the context
const AuthContext = React.createContext();

function App() {
  const [user, setUser] = useState(&#39;John Doe&#39;);

  return (
    &lt;AuthContext.Provider value={{ user, setUser }}&gt;
      &lt;ComponentA /&gt;
    &lt;/AuthContext.Provider&gt;
  );
}

function ComponentA() {
  const { user, setUser } = useContext(AuthContext);
  return (
    &lt;div&gt;
      &lt;p&gt;Welcome, {user}&lt;/p&gt;
      &lt;button onClick={() =&gt; setUser(&#39;Jane Doe&#39;)}&gt;Change User&lt;/button&gt;
      &lt;ComponentB /&gt;
    &lt;/div&gt;
  );
}

function ComponentB() {
  const { user } = useContext(AuthContext);
  return &lt;p&gt;User in Component B: {user}&lt;/p&gt;;
}

export default App;
</code></pre>
<h3 id="when-to-use-context-api">When to Use Context API:</h3>
<ul>
<li><strong>Global State Management</strong>: When you need to share state between components at different levels without passing props down manually at each level.</li>
<li><strong>Avoiding Prop Drilling</strong>: Prop drilling occurs when you pass data down to child components that don&#39;t necessarily need it, but need to pass it along to their children. The Context API eliminates this need.</li>
<li><strong>Theme, Authentication, and Preferences</strong>: Context is useful for things like user authentication state, theme management (light/dark mode), language preferences, etc.</li>
</ul>
<h3 id="limitations">Limitations:</h3>
<ul>
<li><strong>Performance</strong>: Re-renders can happen when the context value changes, which could lead to performance issues if large sections of the app are consuming the context. In such cases, consider using more specific state management tools like Redux or Zustand.</li>
<li><strong>Overuse</strong>: If used excessively, the Context API can lead to unnecessary complexity. For simple cases where only a small number of components need to share data, passing props down directly might be a better approach.</li>
</ul>
<h3 id="conclusion">Conclusion:</h3>
<p>The React Context API is a valuable tool for managing global state in React applications, helping to avoid prop drilling and enabling shared values across components. It&#39;s simple to use with the <code>useContext</code> hook and is perfect for scenarios like global settings, user authentication, or theme management. However, for larger and more complex state management needs, you might want to consider other state management solutions like <strong>Redux</strong> or <strong>Recoil</strong>.</p>

            </div>
        </details>
        <details>
            <summary><strong>Lifting State up</strong></summary>
            <div class="content">
                <h3><strong>Lifting State Up in React</strong></h3>
                <p>In React, <strong>lifting state up</strong> is a
                    concept where state is moved from a child component to a parent component. This allows multiple
                    child
                    components to share and access the same state, enabling communication between them. The parent
                    component
                    manages the shared state, while the child components can receive it as props or trigger state
                    updates
                    via callback functions.</p>
                <h3><strong>Why Lift State Up?</strong></h3>
                <ul>
                    <li><strong>Data Sharing:</strong> When you have multiple components
                        that
                        need to share or modify the same state, it’s best to lift that state to their common ancestor so
                        it
                        can be accessed and updated by those components.</li>
                </ul>
                <ul>
                    <li><strong>Component Communication:</strong> If two sibling components
                        need to communicate with each other or share data, you lift the state up to the closest common
                        parent
                        component, which will pass down the state and callbacks to the children.</li>
                </ul>
                <p>Without lifting state up, each component would have
                    its own isolated state, and they wouldn't be able to directly share data with each other.</p>
                <hr>
                <h3><strong>Example Scenario: Lifting State Up</strong>
                </h3>
                <p>Let’s consider a scenario where two sibling
                    components need to share some data. One component might allow the user to change a value, and the
                    other
                    component needs to display that value. To achieve this, we lift the state up to their parent
                    component.
                </p>
                <h3><strong>Steps:</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Parent Component:</strong> Holds the state and passes it down to child components as
                        props.
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Child Components:</strong> Receive the state via props and update the state via callback
                        functions passed from the parent.</li>
                </ol>
                <hr>
                <h3><strong>Example: Lifting State Up</strong></h3>
                <p>Let’s build a simple example where one child
                    component updates the state (a counter), and another child component displays the counter.</p>
                <h3><strong>Step 1: Lifting the state up to the
                        Parent</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>// Child component 1: Incrementer</span>
  <span>function</span> <span>Incrementer</span><span>(</span><span><span>{</span> onIncrement <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>button onClick<span>=</span><span>{</span>onIncrement<span>}</span><span>&gt;</span>Increment<span>&lt;</span><span>/</span>button<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>// Child component 2: Display</span>
  <span>function</span> <span>Display</span><span>(</span><span><span>{</span> count <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>&lt;</span>h2<span>&gt;</span>Count<span>:</span> <span>{</span>count<span>}</span><span>&lt;</span><span>/</span>h2<span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>// Parent component</span>
  <span>function</span> <span>Parent</span><span>(</span><span>)</span> <span>{</span>
  <span>// State is lifted to the parent component</span>
  <span>const</span> <span>[</span>count<span>,</span> setCount<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>0</span><span>)</span><span>;</span>
  
  <span>// Callback function to update the count</span>
  <span>const</span> <span>incrementCount</span> <span>=</span> <span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setCount</span><span>(</span>count <span>+</span> <span>1</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>{</span><span>/* Passing state and callback to child components */</span><span>}</span>
      <span>&lt;</span>Incrementer onIncrement<span>=</span><span>{</span>incrementCount<span>}</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>Display count<span>=</span><span>{</span>count<span>}</span> <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> Parent<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Parent Component (</strong><code><strong>Parent</strong></code><strong>)</strong>:<ul>
                            <li>Manages the state (<code>count</code>) using
                                <code>useState</code>.
                            </li>
                        </ul>
                        <ul>
                            <li>Provides a callback function (<code>incrementCount</code>)
                                to
                                update the state.</li>
                        </ul>
                        <ul>
                            <li>Passes the state (<code>count</code>) to the
                                <code>Display</code>
                                child component as a prop.
                            </li>
                        </ul>
                        <ul>
                            <li>Passes the <code>incrementCount</code> function to the
                                <code>Incrementer</code> child component as a prop.
                            </li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Child Component 1 (</strong><code><strong>Incrementer</strong></code><strong>)</strong>:
                        <ul>
                            <li>Receives the <code>onIncrement</code> prop, which is a
                                callback
                                function.</li>
                        </ul>
                        <ul>
                            <li>Calls <code>onIncrement</code> when the button is clicked
                                to update
                                the state in the parent component.</li>
                        </ul>
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Child Component 2 (</strong><code><strong>Display</strong></code><strong>)</strong>:<ul>
                            <li>Receives the <code>count</code> prop from the parent and
                                displays
                                the current count value.</li>
                        </ul>
                    </li>
                </ol>
                <hr>
                <h3><strong>Key Concepts of Lifting State Up</strong>
                </h3>
                <ul>
                    <li><strong>State Location:</strong> The state should be in the common
                        ancestor (the parent component) of the components that need access to it. This makes it easier
                        to
                        share the state and pass it down to children as props.</li>
                </ul>
                <ul>
                    <li><strong>State Updates via Callbacks:</strong> The child components
                        cannot directly modify the parent state. Instead, the parent passes a callback function (like
                        <code>onIncrement</code> in the example) to the child, and the child calls the function to
                        trigger
                        state updates in the parent.
                    </li>
                </ul>
                <hr>
                <h3><strong>When to Lift State Up?</strong></h3>
                <ul>
                    <li><strong>Shared State:</strong> When two or more child components
                        need
                        to access or modify the same state.</li>
                </ul>
                <ul>
                    <li><strong>Component Communication:</strong> When sibling components
                        need
                        to communicate or share data.</li>
                </ul>
                <ul>
                    <li><strong>Controlled Components:</strong> When you need to control
                        the
                        behavior of a form or input field in one component based on the state in another component.</li>
                </ul>
                <hr>
                <h3><strong>Example of Lifting State Up for Two Input
                        Components</strong></h3>
                <p>Imagine two input components where the user can type
                    their first and last names in separate fields, but the form needs to display the full name as a
                    combination of both inputs. Instead of each input having its own state, we lift the state up to the
                    parent.</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>// Child component: FirstNameInput</span>
  <span>function</span> <span>FirstNameInput</span><span>(</span><span><span>{</span> firstName<span>,</span> onFirstNameChange <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>First Name<span>:</span><span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>input
        type<span>=</span><span>"text"</span>
        value<span>=</span><span>{</span>firstName<span>}</span>
        onChange<span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>onFirstNameChange</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span>
      <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>// Child component: LastNameInput</span>
  <span>function</span> <span>LastNameInput</span><span>(</span><span><span>{</span> lastName<span>,</span> onLastNameChange <span>}</span></span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>label<span>&gt;</span>Last Name<span>:</span><span>&lt;</span><span>/</span>label<span>&gt;</span>
      <span>&lt;</span>input
        type<span>=</span><span>"text"</span>
        value<span>=</span><span>{</span>lastName<span>}</span>
        onChange<span>=</span><span>{</span><span>(</span><span>e</span><span>)</span> <span>=&gt;</span> <span>onLastNameChange</span><span>(</span>e<span>.</span>target<span>.</span>value<span>)</span><span>}</span>
      <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>// Parent component</span>
  <span>function</span> <span>FullNameForm</span><span>(</span><span>)</span> <span>{</span>
  <span>// State for first name and last name</span>
  <span>const</span> <span>[</span>firstName<span>,</span> setFirstName<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  <span>const</span> <span>[</span>lastName<span>,</span> setLastName<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>''</span><span>)</span><span>;</span>
  
  <span>// Callback to update the first name state</span>
  <span>const</span> <span>handleFirstNameChange</span> <span>=</span> <span>(</span><span>newFirstName</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setFirstName</span><span>(</span>newFirstName<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>// Callback to update the last name state</span>
  <span>const</span> <span>handleLastNameChange</span> <span>=</span> <span>(</span><span>newLastName</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setLastName</span><span>(</span>newLastName<span>)</span><span>;</span>
  <span>}</span><span>;</span>
  
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>FirstNameInput firstName<span>=</span><span>{</span>firstName<span>}</span> onFirstNameChange<span>=</span><span>{</span>handleFirstNameChange<span>}</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>LastNameInput lastName<span>=</span><span>{</span>lastName<span>}</span> onLastNameChange<span>=</span><span>{</span>handleLastNameChange<span>}</span> <span>/</span><span>&gt;</span>
      <span>&lt;</span>h2<span>&gt;</span>Full Name<span>:</span> <span>{</span>firstName<span>}</span> <span>{</span>lastName<span>}</span><span>&lt;</span><span>/</span>h2<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> FullNameForm<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ol type="1" start="1">
                    <li>The <strong>parent component</strong> (<code>FullNameForm</code>) manages the
                        <code>firstName</code>
                        and <code>lastName</code> states.
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li>The <strong>child components</strong> (<code>FirstNameInput</code> and
                        <code>LastNameInput</code>)
                        receive the state as props and can update the state via the callback functions passed from the
                        parent.
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li>The full name is displayed in the parent component by combining the <code>firstName</code> and
                        <code>lastName</code>.
                    </li>
                </ol>
                <hr>
                <h3><strong>Benefits of Lifting State Up</strong></h3>
                <ul>
                    <li><strong>Centralized State Management:</strong> When state is lifted
                        to
                        a parent, it's easier to manage and access in one place, especially when multiple components
                        need
                        access to the same data.</li>
                </ul>
                <ul>
                    <li><strong>Improved Communication:</strong> It enables sibling
                        components
                        to communicate and share data through the parent component, which is the source of truth for the
                        state.</li>
                </ul>
                <ul>
                    <li><strong>Reusability:</strong> Child components become more reusable
                        because they are no longer tied to a specific state—they just rely on the props passed down from
                        the
                        parent.</li>
                </ul>
                <hr>
                <h3><strong>Conclusion</strong></h3>
                <p>Lifting state up in React is a way to share state
                    between components that are not directly connected (i.e., sibling components). By moving the state
                    to
                    the common ancestor, you allow child components to communicate and share data through props and
                    callback
                    functions. This approach improves data management, communication, and reusability across components
                    in a
                    React application.</p>
            </div>
        </details>
        <details>
            <summary><strong>Higher Order Component</strong></summary>
            <div class="content">
                <h3><strong>Higher-Order Components (HOC) in
                        React</strong></h3>
                <p>A <strong>Higher-Order Component (HOC)</strong> is a
                    design pattern in React that allows you to <strong>enhance</strong> or <strong>modify</strong> the
                    behavior of a component by wrapping it with another component. An HOC is a function that takes a
                    component as an argument and returns a new component with enhanced functionality.</p>
                <h3><strong>Key Characteristics of HOC</strong></h3>
                <ol type="1" start="1">
                    <li><strong>A function that takes a component</strong>: The HOC itself is a function that receives a
                        component as an argument.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Returns a new component</strong>: The HOC returns a new component that wraps the
                        original
                        component and provides additional behavior or functionality.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Reusability</strong>: HOCs are used to share common functionality across multiple
                        components, making them reusable.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Does not modify the original component</strong>: HOCs are pure functions. They do not
                        mutate
                        the original component but return a new component.</li>
                </ol>
                <hr>
                <h3><strong>Basic Structure of an HOC</strong></h3>
                <p>The basic structure of a Higher-Order Component
                    looks like this:</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>withSomeFeature</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>EnhancedComponent</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>// Add additional functionality or logic here</span>
  
    <span>return</span> <span>&lt;</span>WrappedComponent <span>{</span><span>...</span>props<span>}</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span><span>;</span>
  <span>}</span>
  </code></pre>
                <p>In the above example:</p>
                <ul>
                    <li><code>withSomeFeature</code> is the HOC.</li>
                </ul>
                <ul>
                    <li><code>WrappedComponent</code> is the component that is passed into
                        the
                        HOC.</li>
                </ul>
                <ul>
                    <li>The returned <code>EnhancedComponent</code> is the new component
                        that
                        contains the original component (<code>WrappedComponent</code>) with additional behavior.</li>
                </ul>
                <hr>
                <h3><strong>Why Use Higher-Order Components?</strong>
                </h3>
                <ul>
                    <li><strong>Code Reusability</strong>: HOCs allow you to encapsulate
                        logic
                        and functionality in a single place, making it reusable across different components.</li>
                </ul>
                <ul>
                    <li><strong>Component Logic Abstraction</strong>: By using HOCs, you
                        can
                        abstract logic that is common across multiple components (e.g., authentication, data fetching,
                        etc.).
                    </li>
                </ul>
                <ul>
                    <li><strong>Separation of Concerns</strong>: HOCs help in separating
                        concerns. You can manage component logic in one place and UI rendering in another.</li>
                </ul>
                <hr>
                <h3><strong>Example of Higher-Order Component</strong>
                </h3>
                <p>Let’s look at a practical example of an HOC that
                    adds loading behavior to a component. The HOC will display a "loading" indicator until the wrapped
                    component has finished fetching its data.</p>
                <h3><strong>Step 1: Create a Basic Component</strong>
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>function</span> <span>UserProfile</span><span>(</span><span><span>{</span> userId <span>}</span></span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>userData<span>,</span> setUserData<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>// Simulate data fetching</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setUserData</span><span>(</span><span>{</span> <span>id</span><span>:</span> userId<span>,</span> <span>name</span><span>:</span> <span>'John Doe'</span><span>,</span> <span>age</span><span>:</span> <span>30</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>userId<span>]</span><span>)</span><span>;</span>
  
  <span>return</span> userData <span>?</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>userData<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Age<span>:</span> <span>{</span>userData<span>.</span>age<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span> <span>:</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> UserProfile<span>;</span>
  </code></pre>
                <h3><strong>Step 2: Create an HOC to Add Loading
                        State</strong></h3>
                <p>Now, let’s create an HOC called
                    <code>withLoading</code> that adds a loading indicator until the wrapped component is ready.
                </p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>withLoading</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>EnhancedComponent</span><span>(</span><span><span>{</span> isLoading<span>,</span> <span>...</span>props <span>}</span></span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>isLoading<span>)</span> <span>{</span>
      <span>return</span> <span>&lt;</span>div<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>  <span>// Show loading indicator when isLoading is true</span>
    <span>}</span>
    <span>return</span> <span>&lt;</span>WrappedComponent <span>{</span><span>...</span>props<span>}</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span><span>;</span>
  <span>}</span>
  </code></pre>
                <h3><strong>Step 3: Use the HOC to Enhance the
                        Component</strong></h3>
                <p>We can now use the <code>withLoading</code> HOC to
                    enhance our <code>UserProfile</code> component.</p>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  <span>import</span> withLoading <span>from</span> <span>'./withLoading'</span><span>;</span>
  
  <span>function</span> <span>UserProfile</span><span>(</span><span><span>{</span> userId <span>}</span></span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>userData<span>,</span> setUserData<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>null</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setUserData</span><span>(</span><span>{</span> <span>id</span><span>:</span> userId<span>,</span> <span>name</span><span>:</span> <span>'John Doe'</span><span>,</span> <span>age</span><span>:</span> <span>30</span> <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span>userId<span>]</span><span>)</span><span>;</span>
  
  <span>return</span> userData <span>?</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span><span>{</span>userData<span>.</span>name<span>}</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
      <span>&lt;</span>p<span>&gt;</span>Age<span>:</span> <span>{</span>userData<span>.</span>age<span>}</span><span>&lt;</span><span>/</span>p<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span> <span>:</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> <span>withLoading</span><span>(</span>UserProfile<span>)</span><span>;</span>
  </code></pre>
                <p>In the example:</p>
                <ul>
                    <li>The <code>withLoading</code> HOC wraps the <code>UserProfile</code>
                        component and adds a loading indicator to it.</li>
                </ul>
                <ul>
                    <li>When <code>isLoading</code> is <code>true</code>, the
                        <code>withLoading</code> HOC will show a loading message; otherwise, it will render the
                        <code>UserProfile</code> component.
                    </li>
                </ul>
                <hr>
                <h3><strong>Example of Usage</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> useState<span>,</span> useEffect <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  <span>import</span> UserProfile <span>from</span> <span>'./UserProfile'</span><span>;</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> <span>[</span>loading<span>,</span> setLoading<span>]</span> <span>=</span> <span>useState</span><span>(</span><span>true</span><span>)</span><span>;</span>
  
  <span>useEffect</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>{</span>
      <span>setLoading</span><span>(</span><span>false</span><span>)</span><span>;</span>  <span>// Simulate loading completion after 3 seconds</span>
    <span>}</span><span>,</span> <span>3000</span><span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
  
  <span>return</span> <span>&lt;</span>UserProfile userId<span>=</span><span>{</span><span>1</span><span>}</span> isLoading<span>=</span><span>{</span>loading<span>}</span> <span>/</span><span>&gt;</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <hr>
                <h3><strong>Common Use Cases for HOCs</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Authorization / Authentication</strong>: You can create an HOC to check if a user is
                        authenticated before allowing them to view certain components or pages.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Fetching Data</strong>: Create an HOC that handles data fetching logic and passes the
                        data
                        down as props to the wrapped component.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Error Boundaries</strong>: HOCs can be used to handle error boundaries and catch
                        JavaScript
                        errors in the component tree.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Theming</strong>: You can use an HOC to inject theme styles or configurations into
                        wrapped
                        components, enabling consistent styling across your application.</li>
                </ol>
                <ol type="1" start="5">
                    <li><strong>Performance Optimizations</strong>: For example, an HOC could be used to implement lazy
                        loading, memoization, or other performance optimization techniques.</li>
                </ol>
                <hr>
                <h3><strong>Advantages of Using HOCs</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Code Reusability</strong>: HOCs allow you to abstract logic that is shared across
                        multiple
                        components and reuse it.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Separation of Concerns</strong>: It separates logic and UI components, making it easier
                        to
                        maintain and scale your application.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Increased Component Composition</strong>: HOCs allow you to combine multiple pieces of
                        logic
                        and functionality in a flexible manner.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Cleaner and Modular Code</strong>: HOCs allow you to write cleaner and more modular code
                        by
                        creating smaller, reusable logic functions.</li>
                </ol>
                <hr>
                <h3><strong>Limitations of HOCs</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Props Conflict</strong>: When wrapping components with HOCs, the original props of the
                        wrapped component and the new props from the HOC can conflict, leading to bugs if not carefully
                        handled.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Nested HOCs</strong>: If you use multiple HOCs on the same component, the component tree
                        can
                        get deeply nested, which can make debugging and testing more difficult.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Readability</strong>: Excessive use of HOCs can sometimes make the code harder to read
                        and
                        understand, especially when there are many layers of HOCs applied to a single component.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Static Methods</strong>: Static methods from the wrapped component will not be available
                        in
                        the HOC unless explicitly forwarded or copied.</li>
                </ol>
                <hr>
                <h3><strong>Conclusion</strong></h3>
                <p>A <strong>Higher-Order Component (HOC)</strong> is a
                    powerful design pattern in React that allows you to add reusable functionality or behavior to a
                    component without modifying the original component. By creating an HOC, you can enhance a component
                    with
                    additional features, such as data fetching, authentication, error handling, or theming, making it
                    more
                    modular and reusable.</p>
                <p>However, while HOCs are very useful, they should be
                    used judiciously as they can introduce complexity and lead to issues like prop conflicts and deeply
                    nested component trees.</p>
            </div>
        </details>
        <details>
            <summary><strong>Error Boundaries</strong></summary>
            <div class="content">
                <p>An <strong>Error Boundary</strong> is a special type
                    of React component that acts as a "catcher" for JavaScript errors anywhere in the component tree. It
                    allows developers to catch errors in a component's lifecycle methods, render methods, and in
                    constructors of any child components. When an error is caught, the Error Boundary prevents the
                    entire
                    app from crashing and can display a fallback UI, allowing the app to continue
                    functioning.<strong><br>Why Use Error Boundaries?<br></strong><br>In React, unhandled errors in
                    components can cause the entire app to crash. Without error boundaries, even a minor issue can bring
                    down the whole app. Error boundaries help you:<br>• Prevent the app from crashing due to unexpected
                    errors in the UI.<br>• Display a user-friendly fallback UI when an error occurs.<br>• Maintain
                    better
                    user experience even in the face of errors.<br><strong><br>How Error Boundaries
                        Work<br></strong><br>Error boundaries work by implementing special lifecycle methods to catch
                    errors:<br>1. <br><code><strong>static getDerivedStateFromError()</strong></code>: This is a static
                    method that is called when an error is thrown. It updates the state of the component so that the
                    fallback UI can be displayed.<br>2. <br><code><strong>componentDidCatch()</strong></code>: This
                    lifecycle method is called after an error is caught. It allows you to log the error, send it to an
                    error
                    reporting service, or take other necessary actions.<strong><br>Creating an Error
                        Boundary<br></strong><br>To create an error boundary, you need to define a class-based component
                    with
                    the following methods:<br>• <br><code><strong>getDerivedStateFromError(error)</strong></code>:
                    Updates
                    the state when an error is thrown.<br>•
                    <br><code><strong>componentDidCatch(error, info)</strong></code>: Handles side effects such as
                    logging
                    the error to an external service.<br>Here’s how you can create an error boundary in
                    React:<br><br><br><code>import React, { Component } from 'react';<br><br>class ErrorBoundary extends Component {<br>  // Step 1: Set up state to track errors<br>  constructor(props) {<br>    super(props);<br>    this.state = { hasError: false, errorInfo: null };<br>  }<br><br>  // Step 2: Get derived state from error<br>  static getDerivedStateFromError(error) {<br>    // Update state to show the fallback UI<br>    return { hasError: true };<br>  }<br><br>  // Step 3: Catch and log errors<br>  componentDidCatch(error, info) {<br>    // Log the error to an external service, if needed<br>    console.error("Error caught by Error Boundary: ", error, info);<br>    // Optionally, send the error to an error tracking service (e.g., Sentry)<br>  }<br><br>  render() {<br>    if (this.state.hasError) {<br>      // Step 4: Show fallback UI if an error is caught<br>      return (<br>        &lt;div&gt;<br>          &lt;h2&gt;Something went wrong. Please try again later.&lt;/h2&gt;<br>        &lt;/div&gt;<br>      );<br>    }<br><br>    // Render the children components if no error occurs<br>    return this.props.children;<br>  }<br>}<br><br>export default ErrorBoundary;<br><br></code><strong><br>Explanation
                        of the Code:<br></strong><br>1. <br><strong>State Management
                        (</strong><code><strong>hasError</strong></code><strong>)</strong>: We maintain a piece of state
                    <code>hasError</code> to check if an error has been caught. If it’s true, the fallback UI is
                    displayed.<br>2. <br><code><strong>getDerivedStateFromError</strong></code>: This static method
                    updates
                    the <code>hasError</code> state when an error occurs.<br>3.
                    <br><code><strong>componentDidCatch</strong></code>: This method catches the error and logs
                    additional
                    information such as error details and component stack trace.<br>4. <br><strong>Fallback UI</strong>:
                    If
                    <code>hasError</code> is true, a fallback UI (like an error message) is displayed instead of the
                    crashed
                    component.<strong><br>Using an Error Boundary<br></strong><br>Once the error boundary is created,
                    you
                    can wrap any component or group of components that you want to catch errors for. If an error occurs
                    in
                    any of the wrapped components, the error boundary will handle it and display the fallback
                    UI.<br><strong><br>Example
                        Usage:<br></strong><br><br><br><code>import React from 'react';<br>import ErrorBoundary from './ErrorBoundary';<br>import UserProfile from './UserProfile';  // Assume UserProfile can throw an error<br><br>function App() {<br>  return (<br>    &lt;div&gt;<br>      &lt;h1&gt;Welcome to the App&lt;/h1&gt;<br><br>      {/* Wrap the UserProfile component with ErrorBoundary */}<br>      &lt;ErrorBoundary&gt;<br>        &lt;UserProfile /&gt;<br>      &lt;/ErrorBoundary&gt;<br>    &lt;/div&gt;<br>  );<br>}<br><br>export default App;<br><br></code><br>In
                    this example:<br>• The <br><code>UserProfile</code> component is wrapped inside an
                    <code>ErrorBoundary</code>.<br>• If an error occurs in the <br><code>UserProfile</code> component,
                    the
                    <code>ErrorBoundary</code> will catch it and display a fallback UI instead of crashing the entire
                    app.<strong><br>Common Use Cases for Error Boundaries<br></strong><br>1. <br><strong>Catching Errors
                        in
                        UI Components</strong>: Any component that might encounter errors, especially those relying on
                    external data (like APIs), can be wrapped in an error boundary. For example, a component fetching
                    user
                    data from an API might throw an error if the data is malformed or missing.<br>2.
                    <br><strong>Preventing
                        App Crashes</strong>: Use error boundaries at key parts of your app where unexpected errors
                    might
                    happen, such as form submissions, user inputs, or third-party libraries.<br>3. <br><strong>Handling
                        Unexpected Errors Gracefully</strong>: An error boundary allows you to show a fallback UI, which
                    gives
                    users a graceful experience even when something goes wrong.<br>4. <br><strong>Logging Errors for
                        Monitoring</strong>: By using <code>componentDidCatch</code>, you can log errors to external
                    services
                    like <strong>Sentry</strong>, <strong>LogRocket</strong>, or <strong>Firebase Crashlytics</strong>
                    for
                    monitoring and alerting.<strong><br>Error Boundaries Limitations<br></strong><br>1.
                    <br><strong>Doesn't
                        Catch Errors in Event Handlers</strong>: Errors thrown inside event handlers (e.g.,
                    <code>onClick</code>) are not caught by error boundaries. For event handlers, you should handle
                    errors
                    using try-catch
                    blocks.<br><br><br><code>function handleClick() {<br>  try {<br>    // Some code that might throw an error<br>  } catch (error) {<br>    console.error("Error in event handler:", error);<br>  }<br>}<br><br></code><br>2.
                    <br><strong>Doesn't Catch Errors in Asynchronous Code</strong>: Errors in asynchronous code (e.g.,
                    <code>setTimeout</code>, <code>fetch</code>, or <code>Promises</code>) are not caught by error
                    boundaries. You should handle those errors using <code>.catch()</code> or <code>try-catch</code> in
                    <code>async</code> functions.<br>3. <br><strong>Doesn't Catch Errors in the Error Boundary
                        Itself</strong>: An error boundary cannot catch errors that occur inside the error boundary
                    component
                    itself. To handle that, you could have nested error boundaries.<strong><br>Best Practices for Using
                        Error Boundaries<br></strong><br>• <br><strong>Use multiple error boundaries</strong>: Instead
                    of
                    having a single global error boundary, use smaller error boundaries around specific sections of your
                    app
                    (e.g., around critical features like forms, data fetching components, or navigation). This allows
                    the
                    rest of the app to function even if one part breaks.<br>• <br><strong>Provide clear fallback
                        UI</strong>: The fallback UI should be simple and provide some helpful information, like an
                    error
                    message or an option to retry. Avoid showing raw errors to users in production.<br>• <br><strong>Log
                        errors to monitoring services</strong>: Use the <code>componentDidCatch</code> method to log
                    errors to
                    external monitoring services like <strong>Sentry</strong> or <strong>LogRocket</strong> to track
                    errors
                    in production.<strong><br>Conclusion<br></strong><br>• <br><strong>Error Boundaries</strong> in
                    React
                    provide a way to catch JavaScript errors in components and display a fallback UI instead of crashing
                    the
                    entire application.<br>• They help improve the <br><strong>user experience</strong> by preventing
                    the
                    app from breaking due to unexpected errors and provide the ability to log errors for debugging.<br>•
                    Error boundaries are an essential part of building production-ready React applications, especially
                    in
                    large-scale apps with complex components.<br>By using error boundaries effectively, you can enhance
                    the
                    resilience of your app, handle errors gracefully, and improve the overall user experience.<br>
                </p>
            </div>
        </details>
        <details>
            <summary><strong>Strict Mode in React</strong> </summary>
            <div class="content">
                <p><strong>React Strict Mode</strong> is a tool
                    designed to help developers write better, more reliable React applications. It is a development-only
                    feature that doesn't affect the production build. It helps identify potential problems in your
                    application by intentionally activating additional checks and warnings in the development
                    environment.
                </p>
                <p>Strict Mode does not render any UI or alter how the
                    app functions but performs checks on your React components to identify issues like unsafe lifecycle
                    methods, deprecated APIs, and unexpected side effects.</p>
                <hr>
                <h3><strong>What Strict Mode Does</strong></h3>
                <p>When enabled, Strict Mode performs the following
                    actions on your application:</p>
                <ol type="1" start="1">
                    <li><strong>Identifying Unsafe Lifecycle Methods</strong>: React warns you about lifecycle methods
                        that
                        are unsafe for async rendering or deprecated.<ul>
                            <li><code>componentWillMount</code></li>
                        </ul>
                        <ul>
                            <li><code>componentWillReceiveProps</code></li>
                        </ul>
                        <ul>
                            <li><code>componentWillUpdate</code></li>
                        </ul>
                        <p>These methods have been deprecated because they
                            cause side effects that can result in unpredictable behavior with React's future
                            asynchronous
                            rendering features.</p>
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Warning About Legacy String Refs</strong>: React will warn if you're using the old
                        string
                        ref API (<code>ref="someName"</code>). It encourages developers to use the newer
                        <strong>callback
                            refs</strong> or <code><strong>React.createRef()</strong></code>.
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Detecting Unexpected Side Effects</strong>: React Strict Mode intentionally
                        double-invokes
                        certain lifecycle methods (like <code>render</code>, <code>constructor</code>,
                        <code>getDerivedStateFromError</code>, and <code>componentDidMount</code>) to identify side
                        effects
                        that are not safe for asynchronous rendering. This helps identify unexpected bugs that can arise
                        in
                        concurrent rendering.
                    </li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Detecting Deprecated Patterns</strong>: It flags deprecated APIs, including old context
                        API
                        or legacy component patterns that should be replaced with the new ones.</li>
                </ol>
                <ol type="1" start="5">
                    <li><strong>Ensuring Components Are Pure</strong>: It helps ensure that components are "pure" and
                        behave
                        as expected by making sure that side effects don’t unintentionally affect other components.</li>
                </ol>
                <hr>
                <h3><strong>How to Enable Strict Mode</strong></h3>
                <p>React Strict Mode is enabled by wrapping your
                    application (or part of it) in a <code>&lt;React.StrictMode&gt;</code> component. This can be done
                    at
                    the root level, or around specific components where you want to perform the checks.</p>
                <h3><strong>Basic Usage:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React <span>from</span> <span>'react'</span><span>;</span>
  <span>import</span> ReactDOM <span>from</span> <span>'react-dom'</span><span>;</span>
  <span>import</span> App <span>from</span> <span>'./App'</span><span>;</span>
  
  ReactDOM<span>.</span><span>render</span><span>(</span>
  <span>&lt;</span>React<span>.</span>StrictMode<span>&gt;</span>
    <span>&lt;</span>App <span>/</span><span>&gt;</span>
  <span>&lt;</span><span>/</span>React<span>.</span>StrictMode<span>&gt;</span><span>,</span>
  document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span>
  <span>)</span><span>;</span>
  </code></pre>
                <p>Here, the entire <code>App</code> component is
                    wrapped in <code>&lt;React.StrictMode&gt;</code>. This means that Strict Mode will be applied to
                    everything inside the <code>App</code> component, including its child components.</p>
                <h3><strong>Usage in Smaller Portions of the
                        App:</strong></h3>
                <p>You can wrap only specific components in Strict Mode
                    if you want to apply the checks to just part of your application.</p>
                <pre tabindex="0"><code class="language-java"><span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Hello<span>,</span> World<span>!</span><span>&lt;</span><span>/</span>h1<span>&gt;</span>
  
      <span>&lt;</span>React<span>.</span>StrictMode<span>&gt;</span>
        <span>&lt;</span>SomeComponent <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>React<span>.</span>StrictMode<span>&gt;</span>
  
      <span>&lt;</span>SomeOtherComponent <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <p>In this example, only <code>SomeComponent</code>
                    will be checked in Strict Mode, and <code>SomeOtherComponent</code> will not be affected.</p>
                <hr>
                <h3><strong>What Happens in Strict Mode?</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Component Lifecycle Methods</strong>: Some lifecycle methods are called multiple times
                        to
                        help identify side effects that could lead to issues. For example, React may call
                        <code>componentDidMount</code> and <code>constructor</code> twice in development mode to verify
                        that
                        your components can be mounted and initialized without causing problems.
                    </li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>State Initialization</strong>: State initialization methods (like
                        <code>getDerivedStateFromProps</code> or <code>getSnapshotBeforeUpdate</code>) are checked for
                        issues,
                        and strict mode ensures they’re behaving correctly with asynchronous updates.
                    </li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Logging Warnings</strong>: React will log helpful warnings to the console if it detects
                        unsafe patterns or deprecated code that could lead to problems in the future.</li>
                </ol>
                <hr>
                <h3><strong>Strict Mode in Action (Double Invoking
                        Functions)</strong></h3>
                <p>In React 18 and beyond, <strong>Strict Mode</strong>
                    helps simulate the behavior of React's new <strong>Concurrent Rendering</strong> by intentionally
                    double-invoking certain lifecycle methods. This is designed to help developers identify side effects
                    or
                    state changes that could be problematic when React switches to async rendering.</p>
                <p>For instance:</p>
                <ul>
                    <li><code><strong>componentDidMount</strong></code> will be called
                        twice.
                    </li>
                </ul>
                <ul>
                    <li><code><strong>constructor</strong></code> will be invoked twice.
                    </li>
                </ul>
                <ul>
                    <li><code><strong>render</strong></code> may be called multiple times.
                    </li>
                </ul>
                <p>This helps simulate how React would behave under
                    concurrent rendering scenarios, where React may decide to pause and restart a component render for
                    efficiency.</p>
                <h3><strong>Example</strong>:</h3>
                <pre tabindex="0"><code class="language-java"><span>class</span> <span>MyComponent</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>"Constructor"</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Component did mount"</span><span>)</span><span>;</span>
  <span>}</span>
  
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"Render"</span><span>)</span><span>;</span>
    <span>return</span> <span>&lt;</span>div<span>&gt;</span>MyComponent<span>&lt;</span><span>/</span>div<span>&gt;</span><span>;</span>
  <span>}</span>
  <span>}</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>React<span>.</span>StrictMode<span>&gt;</span>
      <span>&lt;</span>MyComponent <span>/</span><span>&gt;</span>
    <span>&lt;</span><span>/</span>React<span>.</span>StrictMode<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  </code></pre>
                <p>In the console, you would see:</p>
                <pre tabindex="0"><code class="language-java">Constructor
  Render
  Component did mount
  Constructor
  Render
  Component did mount
  </code></pre>
                <p>This behavior occurs only in development mode with
                    Strict Mode enabled. It doesn’t affect production builds. By observing how components behave when
                    called
                    multiple times, you can identify if side effects are causing problems, ensuring that your components
                    are
                    free of bugs when running concurrently.</p>
                <hr>
                <h3><strong>Benefits of Strict Mode</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Helps to Find Bugs Early</strong>: By identifying problems like side effects, deprecated
                        methods, and unsafe lifecycle methods, React Strict Mode ensures that your app is prepared for
                        future
                        versions of React and runs without issues.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Ensures Code Quality</strong>: It encourages best practices in React development,
                        helping to
                        identify potential performance or reliability issues in the development process.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Prepares for Concurrent Rendering</strong>: With React's upcoming features (like
                        Concurrent
                        Rendering), Strict Mode helps you get ready by ensuring that components behave properly when
                        React's
                        rendering process might be interrupted or paused.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Improves Component Predictability</strong>: Strict Mode helps make sure your components
                        are
                        pure, meaning they won't produce side effects that could interfere with other parts of your app
                        or
                        cause unpredictable behavior.</li>
                </ol>
                <hr>
                <h3><strong>Limitations of React Strict Mode</strong>
                </h3>
                <ol type="1" start="1">
                    <li><strong>Development-Only Feature</strong>: React Strict Mode is only active in development and
                        doesn't affect production builds. This means that it can’t help you catch runtime errors in
                        production. However, this is intentional since it’s a development tool.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>May Cause Performance Overhead in Development</strong>: Because Strict Mode
                        intentionally
                        double-invokes certain lifecycle methods and checks for potential issues, it can introduce a
                        slight
                        performance overhead in development mode. This won't affect production performance.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Might Cause Warnings</strong>: If your code relies on outdated patterns or unsafe
                        lifecycle
                        methods, you might see warnings when using Strict Mode. These warnings are helpful for cleaning
                        up old
                        code, but may cause some temporary noise in the console.</li>
                </ol>
                <hr>
                <h3><strong>When to Use React Strict Mode</strong></h3>
                <ul>
                    <li><strong>During Development</strong>: You should always use Strict
                        Mode
                        during development to catch potential problems early in the development cycle.</li>
                </ul>
                <ul>
                    <li><strong>Refactoring Old Code</strong>: If you’re refactoring or
                        migrating older code to newer versions of React (or preparing for Concurrent Mode), Strict Mode
                        can
                        help you find potential issues that could break when React introduces breaking changes.</li>
                </ul>
                <ul>
                    <li><strong>New Projects</strong>: Always use Strict Mode for new
                        projects
                        to ensure that your codebase is future-proof and follows best practices from the start.</li>
                </ul>
                <hr>
                <h3><strong>Conclusion</strong></h3>
                <p>React Strict Mode is an essential development tool
                    for identifying potential issues in your components before they become bigger problems. By helping
                    you
                    adhere to best practices, check for deprecated lifecycle methods, and catch side effects, it ensures
                    your app is more reliable, ready for future React updates, and properly prepared for concurrent
                    rendering.</p>
                <p>Using React Strict Mode during development is highly
                    recommended as it provides a safety net for developers, helping to improve code quality and
                    application
                    stability in the long run.</p>
            </div>
        </details>
        <details>
            <summary><strong>React Lazy Loading, Code Splitting</strong></summary>
            <div class="content">
                <h3><strong>React Lazy Loading &amp; Code
                        Splitting</strong></h3>
                <p><strong>Lazy Loading</strong> and <strong>Code
                        Splitting</strong> are techniques used to optimize the performance of a React application,
                    particularly in larger applications with a lot of JavaScript code. By loading only the necessary
                    parts
                    of the application when they are needed, these techniques can help reduce the initial loading time,
                    improve page load speed, and enhance the overall user experience.</p>
                <hr>
                <h3><strong>What is Lazy Loading?</strong></h3>
                <p>Lazy loading is a technique where components,
                    resources, or code are only loaded when they are needed. Instead of loading all JavaScript code and
                    assets upfront, lazy loading allows parts of the app to be fetched only when the user interacts with
                    the
                    app or navigates to specific routes.</p>
                <p>In the context of React, lazy loading typically
                    refers to <strong>loading components on demand</strong>, which means components are not included in
                    the
                    main JavaScript bundle when the app is first loaded but instead are loaded only when they are
                    required
                    (e.g., when the user navigates to a specific route or page).</p>
                <hr>
                <h3><strong>What is Code Splitting?</strong></h3>
                <p><strong>Code Splitting</strong> is the process of
                    breaking down your application’s large JavaScript bundle into smaller, more manageable chunks. This
                    allows for <strong>on-demand loading</strong> of code so that only the necessary pieces are loaded
                    at
                    any given time, rather than the entire application being bundled into a single file.</p>
                <p>In React, code splitting is often achieved using
                    <strong>dynamic imports</strong> and <strong>React.lazy</strong>. This way, only the components that
                    are
                    actually required are bundled and delivered to the browser.
                </p>
                <hr>
                <h3><strong>How React Lazy Loading &amp; Code Splitting
                        Work Together</strong></h3>
                <ul>
                    <li><strong>Code Splitting</strong> divides the app into smaller chunks
                        (bundles) that can be loaded independently of each other.</li>
                </ul>
                <ul>
                    <li><strong>Lazy Loading</strong> ensures that these chunks are only
                        loaded
                        when they are needed (e.g., when a user navigates to a page or clicks a button).</li>
                </ul>
                <ul>
                    <li>Together, they minimize the initial loading time of the application
                        by
                        delaying the loading of non-essential components or code until it’s absolutely necessary.</li>
                </ul>
                <hr>
                <h3><strong>React.lazy() for Lazy Loading</strong></h3>
                <p>React provides the <code>React.lazy()</code>
                    function, which enables the dynamic import of components. The component will only be loaded when
                    it’s
                    actually rendered. This is a simple and powerful way to implement lazy loading in React.</p>
                <h3><strong>Syntax:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>const</span> MyComponent <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./MyComponent'</span><span>)</span><span>)</span><span>;</span>
  </code></pre>
                <ul>
                    <li>The <code>import()</code> statement is a <strong>dynamic
                            import</strong> that loads the <code>MyComponent</code> only when it is needed (i.e., when
                        it is
                        rendered).</li>
                </ul>
                <ul>
                    <li><code>React.lazy()</code> returns a React component that can be
                        used
                        like any other component.</li>
                </ul>
                <h3><strong>Example of React.lazy() in Action:</strong>
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Suspense <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  
  <span>// Lazy-load the MyComponent</span>
  <span>const</span> MyComponent <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./MyComponent'</span><span>)</span><span>)</span><span>;</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>div<span>&gt;</span>
      <span>&lt;</span>h1<span>&gt;</span>Lazy Loading <span>with</span> React<span>.</span>lazy<span>&lt;</span><span>/</span>h1<span>&gt;</span>
  
      <span>{</span><span>/* Suspense component is required to display a fallback during loading */</span><span>}</span>
      <span>&lt;</span>Suspense fallback<span>=</span><span>{</span><span>&lt;</span>div<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>}</span><span>&gt;</span>
        <span>&lt;</span>MyComponent <span>/</span><span>&gt;</span>
      <span>&lt;</span><span>/</span>Suspense<span>&gt;</span>
    <span>&lt;</span><span>/</span>div<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><code><strong>React.lazy()</strong></code>: This is used to
                        dynamically
                        import <code>MyComponent</code>. It will only be loaded when <code>MyComponent</code> is
                        rendered.
                    </li>
                </ul>
                <ul>
                    <li><code><strong>Suspense</strong></code>: React's
                        <code>Suspense</code>
                        component is used to handle the loading state. While the lazy-loaded component is being fetched,
                        React
                        will display the fallback UI (<code>&lt;div&gt;Loading...&lt;/div&gt;</code> in this case).
                    </li>
                </ul>
                <h3><strong>Key Points:</strong></h3>
                <ul>
                    <li><code>React.lazy()</code> can only be used for <strong>default
                            exports</strong> of components.</li>
                </ul>
                <ul>
                    <li>You need to wrap the lazy-loaded component with a
                        <code>&lt;Suspense&gt;</code> component. The <code>fallback</code> prop is used to specify the
                        loading
                        indicator that should be displayed while the component is being loaded.
                    </li>
                </ul>
                <hr>
                <h3><strong>Code Splitting with React Router</strong>
                </h3>
                <p>When building larger React applications, combining
                    <strong>lazy loading</strong> with <strong>React Router</strong> can be beneficial. React Router
                    enables
                    route-based code splitting, where each route of the app has its own chunk of code, which is loaded
                    only
                    when the user navigates to that route.
                </p>
                <h3><strong>Example of Code Splitting with React
                        Router:</strong></h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Suspense <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  <span>import</span> <span>{</span> BrowserRouter <span>as</span> Router<span>,</span> Route<span>,</span> Switch <span>}</span> <span>from</span> <span>'react-router-dom'</span><span>;</span>
  
  <span>// Lazy-load the components for each route</span>
  <span>const</span> Home <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./Home'</span><span>)</span><span>)</span><span>;</span>
  <span>const</span> About <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./About'</span><span>)</span><span>)</span><span>;</span>
  <span>const</span> Contact <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./Contact'</span><span>)</span><span>)</span><span>;</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>Router<span>&gt;</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h1<span>&gt;</span>My React App<span>&lt;</span><span>/</span>h1<span>&gt;</span>
        <span>&lt;</span>Suspense fallback<span>=</span><span>{</span><span>&lt;</span>div<span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>}</span><span>&gt;</span>
          <span>&lt;</span>Switch<span>&gt;</span>
            <span>&lt;</span>Route exact path<span>=</span><span>"/"</span> component<span>=</span><span>{</span>Home<span>}</span> <span>/</span><span>&gt;</span>
            <span>&lt;</span>Route path<span>=</span><span>"/about"</span> component<span>=</span><span>{</span>About<span>}</span> <span>/</span><span>&gt;</span>
            <span>&lt;</span>Route path<span>=</span><span>"/contact"</span> component<span>=</span><span>{</span>Contact<span>}</span> <span>/</span><span>&gt;</span>
          <span>&lt;</span><span>/</span>Switch<span>&gt;</span>
        <span>&lt;</span><span>/</span>Suspense<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>&lt;</span><span>/</span>Router<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <h3><strong>Explanation:</strong></h3>
                <ul>
                    <li><strong>React.lazy()</strong>: Each route component
                        (<code>Home</code>,
                        <code>About</code>, <code>Contact</code>) is lazy-loaded when the user navigates to the
                        respective
                        route.
                    </li>
                </ul>
                <ul>
                    <li><strong>React Router’s
                        </strong><code><strong>Switch</strong></code><strong> and
                        </strong><code><strong>Route</strong></code><strong> components</strong>: Define the different
                        routes
                        of the application. Only the required component is loaded when the user navigates to a specific
                        route.
                    </li>
                </ul>
                <ul>
                    <li><strong>Suspense</strong>: A <code>Suspense</code> component wraps
                        the
                        route content to show a fallback UI (loading spinner or text) while waiting for the components
                        to
                        load.</li>
                </ul>
                <hr>
                <h3><strong>Benefits of Code Splitting &amp; Lazy
                        Loading</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Faster Initial Load</strong>: By splitting the code and loading only what's needed
                        initially, the application can load faster. The browser doesn't need to download all the code
                        upfront,
                        reducing the time to first paint (the time it takes for the user to see something on the
                        screen).</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Reduced Bundle Size</strong>: Smaller JavaScript bundles result in quicker downloads,
                        which
                        is especially useful for mobile users or users with slower internet connections.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Improved Performance</strong>: By loading code only when it’s needed (on-demand), lazy
                        loading can significantly improve the performance of larger applications.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Efficient Resource Usage</strong>: Resources (like images, CSS, and JavaScript) are
                        loaded
                        only when required, saving bandwidth and improving overall application efficiency.</li>
                </ol>
                <hr>
                <h3><strong>Handling Loading States with
                        Suspense</strong></h3>
                <p>The <code>Suspense</code> component in React is
                    responsible for rendering a fallback UI while the lazy-loaded component is being fetched. You can
                    customize the fallback UI based on your needs, such as showing a spinner, a loading bar, or just a
                    simple text message.</p>
                <h3><strong>Example with a Loading Spinner:</strong>
                </h3>
                <pre tabindex="0"><code class="language-java"><span>import</span> React<span>,</span> <span>{</span> Suspense <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
  <span>import</span> <span>{</span> BrowserRouter <span>as</span> Router<span>,</span> Route<span>,</span> Switch <span>}</span> <span>from</span> <span>'react-router-dom'</span><span>;</span>
  
  <span>const</span> Home <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./Home'</span><span>)</span><span>)</span><span>;</span>
  <span>const</span> About <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./About'</span><span>)</span><span>)</span><span>;</span>
  <span>const</span> Contact <span>=</span> React<span>.</span><span>lazy</span><span>(</span><span>(</span><span>)</span> <span>=&gt;</span> <span>import</span><span>(</span><span>'./Contact'</span><span>)</span><span>)</span><span>;</span>
  
  <span>function</span> <span>App</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>Router<span>&gt;</span>
      <span>&lt;</span>div<span>&gt;</span>
        <span>&lt;</span>h1<span>&gt;</span>My React App<span>&lt;</span><span>/</span>h1<span>&gt;</span>
        <span>&lt;</span>Suspense fallback<span>=</span><span>{</span><span>&lt;</span>div className<span>=</span><span>"spinner"</span><span>&gt;</span>Loading<span>...</span><span>&lt;</span><span>/</span>div<span>&gt;</span><span>}</span><span>&gt;</span>
          <span>&lt;</span>Switch<span>&gt;</span>
            <span>&lt;</span>Route exact path<span>=</span><span>"/"</span> component<span>=</span><span>{</span>Home<span>}</span> <span>/</span><span>&gt;</span>
            <span>&lt;</span>Route path<span>=</span><span>"/about"</span> component<span>=</span><span>{</span>About<span>}</span> <span>/</span><span>&gt;</span>
            <span>&lt;</span>Route path<span>=</span><span>"/contact"</span> component<span>=</span><span>{</span>Contact<span>}</span> <span>/</span><span>&gt;</span>
          <span>&lt;</span><span>/</span>Switch<span>&gt;</span>
        <span>&lt;</span><span>/</span>Suspense<span>&gt;</span>
      <span>&lt;</span><span>/</span>div<span>&gt;</span>
    <span>&lt;</span><span>/</span>Router<span>&gt;</span>
  <span>)</span><span>;</span>
  <span>}</span>
  
  <span>export</span> <span>default</span> App<span>;</span>
  </code></pre>
                <p>Here, a loading spinner is shown while the component
                    is being loaded. You can replace the fallback content with anything that fits your design, such as a
                    progress bar or animation.</p>
                <hr>
                <h3><strong>Best Practices</strong></h3>
                <ol type="1" start="1">
                    <li><strong>Keep Components Small</strong>: Code splitting is more effective when your components
                        are
                        small and focused. Avoid large monolithic components, as they would still take time to load,
                        defeating
                        the purpose of splitting.</li>
                </ol>
                <ol type="1" start="2">
                    <li><strong>Error Boundaries</strong>: Since lazy loading depends on dynamic imports, you should
                        consider wrapping your lazy-loaded components in <strong>Error Boundaries</strong> to catch
                        potential
                        errors during loading.</li>
                </ol>
                <ol type="1" start="3">
                    <li><strong>Preload Important Components</strong>: For certain components that are critical for the
                        initial user experience (e.g., navigation components or core parts of the UI), consider
                        preloading
                        them so they are available quickly after the initial load.</li>
                </ol>
                <ol type="1" start="4">
                    <li><strong>Limit Usage of Suspense in Large Apps</strong>: While Suspense is a great tool, using it
                        too
                        much can result in too many loading states, which might frustrate users. Be judicious in its
                        use.</li>
                </ol>
                <hr>
                <h3><strong>Conclusion</strong></h3>
                <p><strong>Lazy Loading</strong> and <strong>Code
                        Splitting</strong> are powerful performance optimization techniques in React that help reduce
                    initial
                    load times and improve the user experience. By breaking up large bundles and loading only the
                    necessary
                    parts of the application when needed, you can create faster, more efficient apps.</p>
                <p>In React, <strong>React.lazy</strong> and
                    <strong>Suspense</strong> make implementing lazy loading and code splitting easy, allowing you to
                    dynamically load components and handle loading states seamlessly. These techniques are particularly
                    helpful for large applications and can help significantly enhance performance, especially for users
                    with
                    slower network speeds or on mobile devices.
                </p>
            </div>
        </details>
    </div>

    <div class="home-link">
        <a class="btn btn-primary" href="../../index.html">Home</a>
    </div>

    <script src="../../assests/js/bootstrap.bundle.min.js"></script>
    <script src="../../assests/js/script.js"></script>
    <script src="../../assests/js/prism.min.js"></script>
    <script src="../../assests/js/prism-java.min.js"></script>

</body>

</html>